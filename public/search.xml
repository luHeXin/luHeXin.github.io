<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT B1043 输出PATest (20分)]]></title>
    <url>%2F2021%2F01%2F06%2FB1043%2F</url>
    <content type="text"><![CDATA[题目描述给定一个长度不超过 104 的仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest.... 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 输入格式输入在一行中给出一个长度不超过 104 的、仅由英文字母构成的非空字符串。 输出格式在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例redlesPayBestPATTopTeePHPereatitAPPT 输出样例PATestPATestPTetPTePePee 思路：统计字符串中P、A、T、e、s、t个字符的数目，然后按要求序列输出，并将其相应字符的数目减一，当某一字符数目为零时，不输出。 参考代码11234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;int maxn=10010;int main()&#123; int n=0,countP=0,countA=0,countT=0,counte=0,counts=0,countt=0; char a[maxn]; memset(a,0,sizeof(a)); fgets(a,maxn,stdin); int len=strlen(a); for(int i=0;i&lt;len;i++)&#123; if(a[i]=='P') countP++; else if(a[i]=='A') countA++; else if(a[i]=='T') countT++; else if(a[i]=='e') counte++; else if(a[i]=='s') counts++; else if(a[i]=='t') countt++; &#125; for(int i=0;i&lt;len;i++)&#123; if(countP&gt;0)&#123; countP--; printf("P"); &#125; if(countA&gt;0)&#123; countA--; printf("A"); &#125; if(countT&gt;0)&#123; countT--; printf("T"); &#125; if(counte&gt;0)&#123; counte--; printf("e"); &#125; if(counts&gt;0)&#123; counts--; printf("s"); &#125; if(countt&gt;0)&#123; countt--; printf("t"); &#125; &#125; return 0;&#125; 参考代码2因为已知给定的字符串只含大小写英文字母，因此，用散列的思想更好一些。 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;int maxn=10010;char dict[6]=&#123;'P','A','T','e','s','t'&#125;;int main()&#123; char a[maxn]; int hash[6];//对应PATset六个字符，各个字符出现的次数; int n=0;//记录 PATset六个字符总数 memset(hash,0,sizeof(hash)); fgets(a,maxn,stdin); int len=strlen(a); for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;6;j++)&#123; if(dict[j]==a[i])&#123; hash[j]++; n++; &#125; &#125; &#125; while(n&gt;0)&#123; for(int i=0;i&lt;6;i++)&#123;//每一轮依次检查PATset六个字符 if(hash[i]&gt;0)&#123; printf("%c",dict[i]);//hash[i]记录的是字符个数，dict[i]对应字符内容 hash[i]--; n--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javax.imageio.IIOException:Can't read input file!问题解决]]></title>
    <url>%2F2021%2F01%2F05%2Fjavax-imageio-IIOException-Can-t-read-input-file-%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题描述单元测试时，报错：javax.imageio.IIOException: Can’t read input file! 问题代码12345678910private static String basePath = Thread.currentThread().getContextClassLoader().getResource("").getPath(); // 调用Thumbnails生成带有图片 try &#123; Thumbnails.of(thumbnail.getImage()).size(200, 200) .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(new File(basePath + "/watermark.jpg")), 0.25f) .outputQuality(0.8f).toFile(dest); &#125; catch (IOException e) &#123; logger.error(e.toString()); throw new RuntimeException("创建缩略图失败：" + e.toString()); &#125; 报错信息javax.imageio.IIOException: Can&#39;t read input file! 问题分析及解决图片的路径出了问题，图片是放在D:\JAVA_places\schoolShop\schoolShop\src\main\resources下的，在文件单元测试编译时，会被放在D:\JAVA_places\schoolShop\schoolShop\target\test-classes文件夹中。但是，在单元测试中不能读取D:\JAVA_places\schoolShop\schoolShop\src\main\resources中的内容，因此需将图片放到D:\JAVA_places\schoolShop\schoolShop\src\test\resources文件夹下，这样在编译执行的时候，文件便加载到D:\JAVA_places\schoolShop\schoolShop\target\test-classes文件夹中。当然，直接将图片复制到D:\JAVA_places\schoolShop\schoolShop\target\test-classes文件夹中也是可以解决该问题的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1035 插入与归并 (25分)]]></title>
    <url>%2F2021%2F01%2F04%2FB1035%2F</url>
    <content type="text"><![CDATA[题目描述根据维基百科的定义： 插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。 归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。 现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？ 输入格式输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 输出格式首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 输入样例 110 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 输出样例 1Insertion Sort 1 2 3 5 7 8 9 4 6 0 输入样例 210 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 输出样例 2Merge Sort 1 2 3 8 4 5 7 9 0 6 思路模拟插入和归并排序过程，每进行一次迭代，与输入样例的第三行数据相比较，查看数据是否相同，若判断结果为相同，则还需进行一次迭代。 但注意的一点便是初始数据不参与比较。 数列比较123456bool isSame(int a1[],int b1[])&#123; for(int i=0;i&lt;n;i++)&#123; if(a1[i]!=b1[i]) return false; &#125; return true;&#125; 插入排序12345678910111213int n;void InsertSort(int a[])&#123; for(int i=1 ; i&lt;n ; i++)&#123; int temp=a[i]; int j=i; while(j&gt;0 &amp;&amp; a[j-1]&gt;temp)&#123; //向前挪,前面的值赋给后面 a[j]=a[j-1]; j--; &#125; a[j]=temp; &#125;&#125; 归并排序12345678int n;void mergeSort(int a[])&#123; for(int i=2 ; i/2&lt;=n ; i*=2)&#123; for(int j=0 ; j&lt;n ; j+=i)&#123; sort(a + j , a + min(i + j , n)); &#125; &#125;&#125; 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt; #include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int n,a[101],b[101],ori[101];bool isSame(int a1[],int b1[])&#123; for(int i=0;i&lt;n;i++)&#123; if(a1[i]!=b1[i]) return false; &#125; return true;&#125;void show(int a1[])&#123; for(int i=0;i&lt;n;i++)&#123; printf("%d",a1[i]); if(i!=n-1) printf(" "); &#125;&#125;bool InsertSort()&#123; bool flag=false; for(int i=1;i&lt;n;i++)&#123; if(i!=1&amp;&amp;isSame(ori,b))&#123; flag=true; &#125; int temp=ori[i]; int j=i; while(j&gt;0&amp;&amp;ori[j-1]&gt;temp)&#123; //向前挪,前面的值赋给后面 ori[j]=ori[j-1]; j--; &#125; ori[j]=temp; if(flag==true) return true; &#125; return false;&#125;void mergeSort()&#123; bool flag=false; for(int i=2;i/2&lt;=n;i*=2)&#123; if(i!=2&amp;&amp;isSame(a,b))&#123; flag=true; &#125; for(int j=0;j&lt;n;j+=i)&#123; sort(a+j,a+min(i+j,n)); &#125; if(flag==true) return; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); ori[i]=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;b[i]); &#125; if(InsertSort())&#123; printf("Insertion Sort\n"); show(ori); &#125;else&#123; printf("Merge Sort\n"); mergeSort(); show(a); &#125; return 0; &#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1034 有理数四则运算 (20分)]]></title>
    <url>%2F2021%2F01%2F04%2FB1034%2F</url>
    <content type="text"><![CDATA[题目描述本题要求编写程序，计算 2 个有理数的和、差、积、商。 输入格式输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 输出格式分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。 输入样例 12/3 -4/2 输出样例 12/3 + (-2) = (-1 1/3)2/3 - (-2) = 2 2/32/3 * (-2) = (-1 1/3)2/3 / (-2) = (-1/3) 输入样例 25/3 0/6 输出样例 21 2/3 + 0 = 1 2/31 2/3 - 0 = 1 2/31 2/3 * 0 = 01 2/3 / 0 = Inf 思路分数的表示1234struct fraction &#123; long long up; long long down;&#125;; 最大公因数用于分子分母的约分。方法：辗转相除法。 递归式gcd(a,b)=gcd(b,a%b); 递归边界：gcd(a,0)=a;1234long long gcd(long long a,long long b) &#123; if(b==0) return a; else return gcd(b,a%b);&#125; 分数化简 分母若为负数，则另分子与分母变为各自的相反数，保证符号位看分子而分母恒正。 分数若为零，则另分子为0，分母为1。 约分：分子分母同除以其最大公因数。1234567891011121314151617//分数化简 fraction reduction(fraction result) &#123; //分母小于零，分子分母变为相反数 if(result.down&lt;0)&#123; result.down*=-1; result.up*=-1; &#125; //分子为零，分母变为1 if(result.up==0)&#123; result.down=1; &#125;else&#123;//分子分母同除最大公因数，化简 long long temp=gcd(abs(result.up),abs(result.down)); result.up/=temp; result.down/=temp; &#125; return result;&#125; 分数输出 输出时先化简。 若分母为1，则说明该分数实际为整数，输出分子。 区别假分数与真分数，假分数要以带分数的形式输出。12345678910111213141516//分数输出void show(fraction f)&#123; f=reduction(f); if(f.up&lt;0) printf("("); //整数 if(f.down==1) printf("%lld",f.up); //假分数 else if(abs(f.up)&gt;f.down) &#123;//化简之后f.down是正数，但是f.up不确定 printf("%lld %lld/%lld",f.up/f.down,abs(f.up)%f.down,f.down); &#125;else&#123;//真分数 printf("%lld/%lld",f.up,f.down); &#125; if(f.up&lt;0) printf(")");&#125; 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt; using namespace std;//最大公因式,分数化简 //递归式：gcd(a,b)=gcd(b,a%b)//递归边界：gcd(a,0)=a; long long gcd(long long a,long long b) &#123; if(b==0) return a; else return gcd(b,a%b);&#125;struct fraction &#123; long long up; long long down;&#125;;//分数化简 fraction reduction(fraction result) &#123; //分母小于零，分子分母变为相反数 if(result.down&lt;0)&#123; result.down*=-1; result.up*=-1; &#125; //分子为零，分母变为1 if(result.up==0)&#123; result.down=1; &#125;else&#123;//分子分母同除最大公因数，化简 long long temp=gcd(abs(result.up),abs(result.down)); result.up/=temp; result.down/=temp; &#125; return result;&#125;//分数相加，最后输出化简后的结果 fraction add(fraction f1,fraction f2)&#123; fraction result; result.up=f1.down*f2.up+f1.up*f2.down; result.down=f1.down*f2.down; return reduction(result);&#125;//减fraction sub(fraction f1,fraction f2)&#123; fraction result; result.up=f1.up*f2.down-f1.down*f2.up; result.down=f1.down*f2.down; return reduction(result);&#125; //乘fraction mult(fraction f1,fraction f2)&#123; fraction result; result.up=f1.up*f2.up; result.down=f1.down*f2.down; return reduction(result);&#125; //除fraction divide(fraction f1,fraction f2)&#123; fraction result; result.up=f1.up*f2.down; result.down=f1.down*f2.up; return reduction(result);&#125; //分数输出void show(fraction f)&#123; f=reduction(f); if(f.up&lt;0) printf("("); //整数 if(f.down==1) printf("%lld",f.up); //假分数 else if(abs(f.up)&gt;f.down) &#123;//化简之后f.down是正数，但是f.up不确定 printf("%lld %lld/%lld",f.up/f.down,abs(f.up)%f.down,f.down); &#125;else&#123;//真分数 printf("%lld/%lld",f.up,f.down); &#125; if(f.up&lt;0) printf(")");&#125; int main() &#123; fraction a,b; scanf("%lld/%lld %lld/%lld",&amp;a.up,&amp;a.down,&amp;b.up,&amp;b.down); //加法 show(a); printf(" + "); show(b); printf(" = "); show(add(a,b)); printf("\n"); //减法 show(a); printf(" - "); show(b); printf(" = "); show(sub(a,b)); printf("\n"); //乘法 show(a); printf(" * "); show(b); show(mult(a,b)); printf("\n"); //除法 show(a); printf(" / "); show(b); printf(" = "); if(b.up==0) printf("Inf"); else show(divide(a,b)); return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF201412-2]]></title>
    <url>%2F2020%2F04%2F19%2Fcsp201412-2%2F</url>
    <content type="text"><![CDATA[问题链接：CCF201412-2 问题描述给定一个n×n的矩阵，左上角到右下角Z字形扫描输出该矩阵的元素。先输入正整数n，再输入n×n个整数。 题目分析模拟关键在于找到下标的变化规律，可以发现扫描过程中共有四种方向，即右，下，右上，左下四个方向每进行一次的右或下的扫描后,则会进行若干次的右上或左下的扫描。不难发现最后一次扫描必定是右或下,第一次扫描必定是右若此次是右扫描,且扫描位置在矩形的上边界,则下次一定会进行若干次的左下扫描。直至到达矩形的左边界或下边界若此次是右扫描,且扫描位置在矩形的上边界,则下次一定会进行若干次的右上扫描。直至到达矩形的右边界或上边界同理，此次若为上扫描，亦然，不在此多加赘述。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;int main() &#123; int n; cin&gt;&gt;n; int a[n+1][n+1]; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; if(n==1) &#123; cout&lt;&lt;a[1][1]; return 0; &#125; cout&lt;&lt;a[1][1]&lt;&lt;" "; int ii=1,jj=1; //flag1=1表示可以右走，-1为向下走，为0是代表斜着走 //flag2=1代表斜向上走 ,-1表示斜向下走 int flag1=1,flag2=1; while(1) &#123; if(flag1==1)&#123;//右走 jj++; cout&lt;&lt;a[ii][jj]; flag1=0; if(ii==1) flag2=-1; if(ii==n) flag2=1; &#125; else if(flag1==-1)&#123;//下走 ii++; cout&lt;&lt;a[ii][jj]; flag1=0; if(jj==1) flag2=1; if(jj==n) flag2=-1; &#125; if(ii&gt;=n&amp;&amp;jj&gt;=n) break; else cout&lt;&lt;" "; while(flag2==-1&amp;&amp;flag1==0) &#123; //斜向下走 ii++; jj--; cout&lt;&lt;a[ii][jj]&lt;&lt;" "; if(jj==1&amp;&amp;ii!=n)&#123; flag1=-1;//向下走 break; &#125; if(ii==n)&#123; flag1=1;//向右走 break; &#125; &#125; while(flag2==1&amp;&amp;flag1==0) &#123; //斜向上走 ii--; jj++; cout&lt;&lt;a[ii][jj]&lt;&lt;" "; if(ii==1&amp;&amp;jj!=n)&#123; flag1=1;//向右走 break; &#125; if(jj==n)&#123; flag1=-1;//向下走 break; &#125; &#125; &#125; return 0;&#125; 小结 当n=1时，需特殊讨论 因为赋值时，数组脚标从1至n的，因此开辟的数组大小为n+1]]></content>
      <categories>
        <category>CCF计算机软件能力认证</category>
      </categories>
      <tags>
        <tag>CCF</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树先序遍历与后序遍历之间的转换]]></title>
    <url>%2F2020%2F03%2F11%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[思路在二叉搜索树中，左子树的所有结点的权值小于根结点的权值，右子树的所有结点的权值大于等于根结点的权值根据二叉搜索树的这条特性便可以找到，先序(或后序)遍历数组中对应的左右子树的子序列，在多次递归即可。 已知二叉搜索树的先序遍历求其后序遍历123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; pre,post;void postOrder(int root,int end) &#123;//root与end对应先序遍历数组的第一个元素下标，及最后一个元素下标 if(root&gt;end) return;//递归边界 int i=root+1; int j=end; //根据二叉搜索树right&lt;root&lt;left的特点，进行遍历,找到先序数组中左右子树的范围 //左子树序列是[root+1,j]; //右子树序列是[i,end] while(i&lt;=end&amp;&amp;pre[root]&gt;pre[i]) i++; //i从左子树序列第一个开始，搜索到右子树序列第一个结束 while(j&gt;=root+1&amp;&amp;pre[root]&lt;=pre[j]) j--; //j从右子树最后一个开始，搜索到左子树最后一个结束 if(j+1!=i) return; postOrder(root+1,j);//左子树 postOrder(i,end);//右子树 post.push_back(pre[root]);&#125;int main() &#123; int n; cin&gt;&gt;n; pre.resize(n); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;pre[i]; &#125; postOrder(0,n-1); for(auto it=post.begin();it!=post.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" "; &#125; return 0;&#125; 已知二叉搜索树的先序遍历求其后序遍历123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; pre,post;void preOrder(int root,int start)&#123; if(root&lt;start) return; int i=root-1; int j=start; while(i&gt;=start&amp;&amp;post[root]&lt;=post[i]) i--; while(j&lt;=root-1&amp;&amp;post[root]&gt;post[j]) j++; if(i+1!=j) return; pre.push_back(post[root]); preOrder(i,start); //这里注意，左子树数组为[start,i],但由于数组是后序遍历数组，所以左子树的根是i preOrder(root-1,j); &#125;int main() &#123; int n; cin&gt;&gt;n; post.resize(100); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;post[i]; &#125; preOrder(n-1,0); for(auto it=pre.begin();it!=pre.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1060 Are They Equal (25分)]]></title>
    <url>%2F2020%2F02%2F26%2FA1060%2F</url>
    <content type="text"><![CDATA[Problem DescriptionIf a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as 0.123×10^5 with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine. Input Specification:Each input file contains one test case which gives three numbers N, A and B, where N (&lt;100) is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than 10^100, and that its total digit number is less than 100. Output Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]…d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line. Note: Simple chopping is assumed without rounding. Sample Input1:3 12300 12358.9 Sample Output1:YES 0.123*10^5 Sample Input1:3 120 128 Sample Output1:NO 0.12010^3 0.12810^3 思路： 先将样例格式转换为0.a1a2a3....x10^e(a1不为零),获取数值本体部分和指数部分，进行比较比较。 但是，所给数据可能出现如下特殊情况，需进一步处理： 000000.0000000xxxx 000000.xxxxxx 00000000000xxxxxxxx 0000xxx.xxxxxx 大概思路为-&gt;删除多余0位-&gt;找到小数点(并删除)-&gt;确定指数e-&gt;在没有小数点，没有高位0的情况下，可确定整数部分a1a2a3a4-&gt;根据精度，添加0位具体处理过程为： 第一个非零位前的0均删除 如果去掉多余零后，是小数点(对应上述前两中情况)，则说明小于1，删除小数点，删除零，继续寻找有效数位。 如果去掉多余零后，是整数(对应上述后两种情况),则说明大于等于1，寻找小数点，删除小数点。 如果去掉多余的零后，长度为零，做说明原数为零，将e赋值0。 如果精度没到要求，补零。 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int change(string &amp;s1,int n) &#123; //返回10的指数,n位有效位数 int len=s1.length(); int e=0; while(s1[0]=='0'&amp;&amp;s1.length()&gt;0) &#123; //删除多余零 s1.erase(s1.begin()); &#125; if(s1[0]=='.') &#123; s1.erase(s1.begin());//删除小数点 while(s1[0]=='0'&amp;&amp;s1.length()&gt;0) &#123; //删除多余零，这是可得到整数部分a1a2a3...(a1&gt;0) s1.erase(s1.begin()); e--;//每删除一位，指数-1 &#125; &#125; else if(s1[0]!='.') &#123; //因为多余的零被删除，所以此时，不是小数点 就是整数 for(int i=0; i&lt;s1.length(); i++) &#123; if(s1[i]=='.') &#123; //找到小数点 s1.erase(s1.begin()+i);//删除小数点，保留整数 e=i; break; &#125; else &#123; //没有小数点纯整数 e=i+1; &#125; &#125; &#125; if(s1.length()==0) &#123; e=0; &#125; if(s1.length()&gt;=n) &#123; //得舍 s1=s1.substr(0,n); &#125; else &#123; while(s1.length()&lt;n) &#123; s1+='0'; &#125; &#125; return e;&#125;int main() &#123; int n; string s1,s2; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; int poly1=change(s1,n); int poly2=change(s2,n); if((s1==s2)&amp;&amp;(poly1==poly2)) &#123; cout&lt;&lt;"YES 0."&lt;&lt;s1&lt;&lt;"*10^"&lt;&lt;poly1; &#125; else &#123; cout&lt;&lt;"NO 0."&lt;&lt;s1&lt;&lt;"*10^"&lt;&lt;poly1&lt;&lt;" 0."&lt;&lt;s2&lt;&lt;"*10^"&lt;&lt;poly2; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大整数运算]]></title>
    <url>%2F2020%2F02%2F25%2F%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[大整数又称为高精度整数，其含义就是用基本数据类型无法存储其精度的整数。 大整数的存储12345678struct bign&#123; int d[1000]; //存储大整数数据 int len; //存储大整数长度 bign()&#123; memset(d,0,sizeof(d)); int len=0; &#125;&#125; 为了方便后续的运算，整数的高位最好对应大整数数组的高位。 12345678bign change(char s[])&#123; bign ans; ans.len=strlen(s); for(int i=0;i&lt;ans.len;i++)&#123;//整数的高位对应大整数数组的高位 ans.d[i]=s[ans.len-1-i]-'0'; &#125; return ans;&#125; 比较大整数大小: 比较大整数长度 按高位向低位依次比较1234567891011int compare(bign a,bign b) &#123; if(a.len&gt;b.len) return 1; else if(a.len&lt;b.len) return -1; else &#123; for(int i=a.len-1; i&gt;=0; i--) &#123; if(a.d[i]&gt;b.d[i]) return 1; else if(a.d[i]&lt;b.d[i]) return -1; &#125; return 0;//二者相等 &#125;&#125; 大整数四则运算加法12345678910111213bign add(bign a,bign b)&#123;//加法 bign ans; int carry=0; //carry保留进位 for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; int temp=a.d[i]+b.d[i]+carry; carry=temp/10; ans.d[ans.len++]=temp%10; &#125; if(carry!=0)&#123;//还得继续进一位 ans.d[ans.len++]=carry; &#125; return ans;&#125; 减法1234567891011121314151617181920bign sub(bign a,bign b)&#123;//减法 if(compare(a,b)==-1)&#123;//交换被减数与减数，保证被减数大 bign temp=a; a=b; b=temp; printf("-");//输出负号 &#125; bign ans; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; if(a.d[i]&lt;b.d[i])&#123;//不够减 a.d[i+1]--;//借位 a.d[i]+=10; &#125; ans.d[ans.len++]=a.d[i]-b.d[i]; &#125; while(ans.len-1&gt;=1&amp;&amp;ans.d[ans.len-1]==0)&#123; ans.len--; &#125; return ans;&#125; 乘法1234567891011121314bign multi(bign a,int b)&#123;//乘法 bign ans; int carry=0; for(int i=0;i&lt;a.len;i++)&#123; int temp=a.d[i]*b+carry; ans.d[ans.len++]=temp%10; carry=temp/10; &#125; while(carry!=0)&#123;//最后还有进位 ans.d[ans.len++]=carry%10; carry/=10; &#125; return ans;&#125; 除法12345678910111213141516bign div(bign a,int b,int &amp;r)&#123;//r保存余数,初值应为零 bign ans; ans.len=a.len; for(int i=a.len-1;i&gt;=0;i--)&#123;//除法从高位开始 r=r*10+a.d[i]; if(r&lt;b) ans.d[i]=0;//不够除,0补位,继续下一位的计算 else&#123;//够除 ans.d[i]=r/b; r=r%b;//更新余数 &#125; &#125; while(ans.len-1&gt;=1&amp;&amp;ans.d[ans.len-1]==0) &#123; ans.len--;//高位为零，舍去。but，各位都是零，个位不舍 &#125; return ans;&#125; Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;struct bign &#123; int len; int d[1000]; bign() &#123; memset(d,0,sizeof(d)); len=0; &#125;&#125;;bign change(char s[]) &#123;//转化为大整数，大整数低位存储数据低位 bign ans; ans.len=strlen(s); for(int i=0; i&lt;ans.len; i++) &#123; ans.d[i]=s[ans.len-1-i]-'0'; &#125; return ans;&#125;int compare(bign a,bign b) &#123;//比较大小 if(a.len&gt;b.len) return 1; else if(a.len&lt;b.len) return -1; else &#123; for(int i=a.len-1; i&gt;=0; i--) &#123; if(a.d[i]&gt;b.d[i]) return 1; else if(a.d[i]&lt;b.d[i]) return -1; &#125; return 0;//二者相等 &#125;&#125;bign add(bign a,bign b)&#123;//加法 bign ans; int carry=0; //carry保留进位 for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; int temp=a.d[i]+b.d[i]+carry; carry=temp/10; ans.d[ans.len++]=temp%10; &#125; if(carry!=0)&#123;//还得继续进一位 ans.d[ans.len++]=carry; &#125; return ans;&#125;bign sub(bign a,bign b)&#123;//减法 if(compare(a,b)==-1)&#123;//交换被减数与减数，保证被减数大 bign temp=a; a=b; b=temp; printf("-");//输出负号 &#125; bign ans; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; if(a.d[i]&lt;b.d[i])&#123;//不够减 a.d[i+1]--;//借位 a.d[i]+=10; &#125; ans.d[ans.len++]=a.d[i]-b.d[i]; &#125; while(ans.len-1&gt;=1&amp;&amp;ans.d[ans.len-1]==0)&#123; ans.len--; &#125; return ans;&#125;bign multi(bign a,int b)&#123;//乘法 bign ans; int carry=0; for(int i=0;i&lt;a.len;i++)&#123; int temp=a.d[i]*b+carry; ans.d[ans.len++]=temp%10; carry=temp/10; &#125; while(carry!=0)&#123;//最后还有进位 ans.d[ans.len++]=carry%10; carry/=10; &#125; return ans;&#125;bign div(bign a,int b,int &amp;r)&#123;//r保存余数,初值应为零 bign ans; ans.len=a.len; for(int i=a.len-1;i&gt;=0;i--)&#123;//除法从高位开始 r=r*10+a.d[i]; if(r&lt;b) ans.d[i]=0;//不够除,0补位,继续下一位的计算 else&#123;//够除 ans.d[i]=r/b; r=r%b;//更新余数 &#125; &#125; while(ans.len-1&gt;=1&amp;&amp;ans.d[ans.len-1]==0) &#123; ans.len--;//高位为零，舍去。but，各位都是零，个位不舍 &#125; return ans;&#125; void print(bign a)&#123;//输出 for(int i=a.len-1;i&gt;=0;i--)&#123; printf("%d",a.d[i]); &#125;&#125;int main() &#123; int q=9;//乘法乘数，除法除数 int r=0;//保留余数 char s1[1000],s2[1000]; cin&gt;&gt;s1&gt;&gt;s2; //转换为大整数 bign a=change(s1); bign b=change(s2); bign add1=add(a,b); //加 bign sub1=sub(a,b); //减 bign multi1=multi(a,q); //乘 bign div1=div(a,q,r); //除 print(add1); return 0;&#125;&#125; Tips 加法与乘法要注意最后进位的处理，比如99+11，各位相加以后，还要最后进一位，进位到百位。 乘法的最后进位可能不止一位，所以最后要用while，如100*100=10000最后在百位的基础上又进了两位。 减法和除法要注意高位零的舍去，但是，假如全是零，例如0000000，则要保留个位的0。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PAT 1025 PAT Ranking (25分)]]></title>
    <url>%2F2020%2F02%2F16%2FPAT-1025-PAT-Ranking-25%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem DescriptionProgramming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input SpecificationEach input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output SpecificationFor each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rank The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input2 5 1234567890001 95 1234567890005 100 1234567890003 95 1234567890002 77 1234567890004 85 4 1234567890013 65 1234567890011 25 1234567890014 100 1234567890012 85 Sample Output91234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 题目大意有N个考场，每个考场有K名学生，根据考生PAT分数，分别记录本考场成绩的排名，以及所有考场所有考生成绩的总排名，若名次相同则按学号升序排列。 思路排序问题因为有N个考场，每个考场有K名考生(K是变量)，因此总共有N*K名学生。考场排序：定义一个变量’count’(0≤count≤N x K-1)给每位考生进行编号。每读入一个考场的信息，将该考场的考生依次编号为count-k至count,并按排序规则排序(成绩降序，成绩相同，考号升序)，若编号为j的考生的分数与j-1考生分数相同，说明名次并列，令j排名与j-1相等；若不同则令j考生的名次为j-count+k+1。全部排序：按照排序规则sort(0,count,cmp)变量间关系详见参考代码 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;const int maxn=100010;struct Node&#123; char id[15]; int score=-1; int frank; int lrank; int lnum;&#125;node[maxn];bool cmp(Node a,Node b)&#123; if(a.score!=b.score) return a.score&gt;b.score; else return strcmp(a.id,b.id)&lt;0;&#125;int main() &#123; int n,k,score; char id[15]; scanf("%d",&amp;n); int count=0; for(int i=1;i&lt;=n;i++)&#123;//有n个考场，其编号依次为[1,n] scanf("%d",&amp;k); for(int j=0;j&lt;k;j++)&#123; scanf("%s %d",id,&amp;score); strcpy(node[count].id,id); node[count].score=score; node[count].lnum=i; count++;//记录总考试人数 &#125; sort(node+count-k,node+count,cmp);//该考场考生序号为[count-k,count-1],因此按照sort()函数语法，指向末地址下一个 node[count-k].lrank=1;//将该考场最高分名次置为1，为了后续与前者比较，分数相同则并列 for(int j=count-k+1;j&lt;count;j++)&#123;//循环记录每位考生在自己考场的排名 if(node[j-1].score==node[j].score) node[j].lrank=node[j-1].lrank;//并列 else node[j].lrank=j-count+k+1;//注意排名是从1开始的，而j-count+k为该考场第一个人的结构体数组下标其数值为0. &#125; &#125; sort(node,node+count,cmp);//所有考场，所有学生排序 node[0].frank=1; for(int j=1;j&lt;count;j++)&#123;//记录每位考生在所有考场的总排名 if(node[j].score==node[j-1].score) node[j].frank=node[j-1].frank; else node[j].frank=j+1; &#125; printf("%d\n",count); for(int i=0;i&lt;count;i++)&#123; printf("%s %d %d %d\n",node[i].id,node[i].frank,node[i].lnum,node[i].lrank); &#125; return 0; &#125; 其实，这么写时间复杂度是非常高的，我有一个好的办法只是这里位置太小写不下(手动狗头)，(By the way,感谢姥姥对小白的不杀之恩，呜呜呜~)，哎，路漫漫其修远兮，(表述能力)&amp;&amp;(代码功底)还需加强兮。]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[简介并查集是一种维护集合的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。并查集中的查询指的是判断两个元素是否在一个集合。对同一个集合来说只存在一个根节点，且将其作为所属集合的标识。 并查集实现并查集的实现就是一个数组 1int father[N]; father[i]表示元素i的直属父节点，对于根节点而言，father[i]=i。 并查集的基本操作初始化123456int father[N];void init(int n)&#123; for(int i=;i&lt;n;i++)&#123; father[i]=i; &#125;&#125; 查找由于并查集每个集合只有一个根节点，因此并查集的根节点可视为集合的标识，查找的结果便是返回该集合的根节点。 123456int findFather(int x)&#123; while(x!=father[x])&#123;//根节点的father为自身 x=father[x];//不断地更新x，直至到达根节点 &#125; return x;&#125; 合并合并的基础是查询，先查找两个元素所在集合的根节点，若根节点不相同，则说明元素所在集合不相同，将其中一个集合的根节点的父亲指向另一个集合的根节点即可。 123456789101112131415161718192021void Union(int A,int B)&#123; int faA=findFather(A); int faB=findFather(B); if(faA!=faB)&#123; father[faA]=faB;//进行合并 &#125;&#125;``` ## 计算集合个数``` c++int isRoot[N];//判断该节点是否为根结点，是为1，不是为0，但是注意要进行初始化附零处理，这里不加赘述int calBlock(int n)&#123;//n为总共元素数目，元素序号从1~n int block=0; for(int i=1;i&lt;=n;i++)&#123; isRoot[findFather(i)]=1;//将根节点赋值为1 &#125; for(int i=1;i&lt;=n;i++)&#123; block+=isRoot[i];//计算根节点数目（由于一个集合只有一个根节点，因此几个根节点，便是几个集合） &#125; return block;&#125;]]></content>
      <categories>
        <category>PAT模板</category>
      </categories>
      <tags>
        <tag>PAT模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS and BFS]]></title>
    <url>%2F2020%2F01%2F28%2FDFS-and-BFS%2F</url>
    <content type="text"><![CDATA[DFS简述DFS即深度优先搜索，是一种枚举所有完整路径以遍历所有情况的搜索方法。以“深度”为前进的关键词，不碰到死胡同就不回头。使用递归可以很好地实现深度优先搜索，递归中的递归式就是岔道口，递归边界就是死胡同。 模板12345678DFS(depth,..)&#123; if(找到解||死胡同)&#123;//递归边界 ... return; &#125; ... DFS(depth+1,...);//枚举下一种情况&#125; 使用DFS遍历树对于树而言，DFS的“死胡同”就等价于树中的叶子结点，而“岔道口”相当于树的非叶子结点。 123456789void DFS(int index)&#123; if(Node[index].child.size()==0&#123;//到达叶子结点 return; &#125; for(int i=0;i&lt;Node[index].child.size();i++)&#123; int child=Node[index].child[i]; DFS(child); &#125;&#125; 使用DFS遍历图DFS遍历图的基本思路是将经过的顶点设置为已访问，下次递归碰到该顶点时不再去处理，直到整个图的顶点都被标记为已访问。 12345678910111213141516DFS(U)&#123;//访问顶点u vis[u]=true;//设u为已被访问 for(从u出发能到达的所有顶点v)&#123; if(vis[v]==false)&#123; DFS(v);//访问v &#125; &#125;&#125;DFSTrave(G)&#123;//遍历图G for(G的所有顶点u)&#123; if(vis[u]==false)&#123;//u未被访问 DFS(u);//访问u所在的连通块 &#125; &#125;&#125; 如果图为连通图(任意两个顶点都联通)，则只需要一个DFS即可。 BFS简述BFS即广度优先搜索，以广度为第一搜索。当碰到岔路口时，不是一根筋的往下走，遇到“南墙”为止。而是，依次访问该岔路口可以直接到达的所有结点，然后再按这些结点被访问的顺序去一次访问他们所能达到的所有结点。BFS一般由队列实现，且总是按层次的顺序进行遍历。 模板12345678910void BFS(int s)&#123; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int front=q.front();//取出队首元素 //访问队首元素 q.pop();//队首元素出队 //将下一层为入队的结点入队，并设置为已入队 &#125;&#125; 使用BFS遍历树就树而言，BFS问题可转换为层序遍历问题。 123456789101112void BFS(int root)&#123; queue&lt;int&gt; q; q.push(root); while(!q.empty())&#123; int front=q.front();//取出队首元素 q.pop(); for(int i=0;i&lt;Node[front].child.size();i++)&#123; int child=Node[front].child[i]; q.push(child); &#125; &#125;&#125; 使用BFS遍历图先建立一个队列，把初始顶点加入队列，此后每次都取出队首顶点进行访问，并把该点出发可以达到的未曾加入过队列(而不是未访问)的顶点全部加入队列，直到队列为空。 123456789101112131415161718192021BFS(u)&#123;//遍历u所在的连通块 queue q; 将u入队; inq[u]=true;//设置已入队 while(!q.empty())&#123; 取出q的队首元素进行访问; for(从u出发可以到达的所有顶点v)&#123; if(inq[v]==false)&#123;//如果为入队 将v入队; inq[v]=true; &#125; &#125; &#125;&#125;BFSTrave(G)&#123;//遍历图G for(G的所有顶点u)&#123;//枚举G的所有顶点 if(inq[u]==false)&#123; BFS(u);//遍历u所在的连通块 &#125; &#125;&#125; 图的BFS和DFS类似，假如图是连通图，则只需要一次BFS即可。]]></content>
      <categories>
        <category>PAT模板</category>
      </categories>
      <tags>
        <tag>PAT模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT模板———使用Dijkstra算法记录所有最短路径]]></title>
    <url>%2F2020%2F01%2F20%2FPAT%E6%A8%A1%E6%9D%BF%E2%80%94%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Dijkstra%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E6%89%80%E6%9C%89%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031vector&lt;int&gt; pre[maxv];//保留前驱结点int d[maxv];//记录距离，如d[2]便是起点到节点2的距离int n;//n个结点bool vis[maxv]=&#123;false&#125;;//标记结点是否被访问void Dijkstra(int s)&#123;//s为起点2 fill(d,d+maxv,inf);//数组初始化，inf为无穷 d[s]=0; for(int i=0;i&lt;n;i++)&#123;//寻找中介结点 int u=-1,min=inf;//u为中介结点（与起始节点最近的点），min为最近距离 for(int j=0;j&lt;n;j++)&#123; if(vis[j]==false&amp;&amp;d[u]&lt;min)&#123; min=d[j]; u=j; &#125; &#125; if(u==-1) return; vis[u]=true; for(int v=0;v&lt;n;v++)&#123;//进行松弛 if(vis[u]==false&amp;&amp;G[u][v]!=inf)&#123;//中介点u未访问，且中介点u与目标终点v之间连通 if(d[u]+G[u][v]&lt;d[v])&#123;//可以松弛 d[v]=d[u]+G[u][v]; pre[v].clear();//清空pre[v] pre[v].push_back(u);//v的前驱为u &#125;else if(d[u]+G[u][v]==d[v])&#123;//存在长度相同的不同路线的最短路径 pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT模板</category>
      </categories>
      <tags>
        <tag>PAT模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树几种遍历方法间的转换]]></title>
    <url>%2F2020%2F01%2F06%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言二叉树的遍历是指通过一定顺序访问二叉树的所有结点。遍历方法一般有四种：先序遍历、中序遍历、后序遍历及层序遍历。其中已知先序(或后序)与中序可以求出后序(或先序)遍历。但是，若只知道先序与后序则就不出中序遍历。 案例已知如下一棵二叉树：先序遍历：4 1 3 2 6 5 7中序遍历：1 2 3 4 5 6 7后序遍历：2 3 1 5 7 6 4层序遍历：4 1 6 3 5 7 2 思路 先序遍历数组中第一个元素为根结点。 后序遍历数组最后一个元素则为根结点。 中序遍历数组中，找到根结点，则根结点左侧为左子树，右侧为右子树。 对于求层序遍历的问题，只需在先序或者是后序遍历过程中，用一个变量来记录当前根结点在⼆叉树中所对应的下标，根据下标进行结构体的排序，按顺序输出即可。已知先序与中序求后序12345678910111213141516171819202122232425#include&lt;cstdio&gt;int pre[32],in[32];//pre[]是先序遍历数组，in[]是中序遍历数组 void post(int root,int start,int end)&#123;//root是先序遍历数组中的根节点脚标 if(start&gt;end) return; int i=start; while(i&lt;end&amp;&amp;in[i]!=pre[root]) i++;//i是中序遍历数组中根节点脚标 post(root+1,start,i-1);//左子树递归 post(root+1-start+i,i+1,end);//右子树递归 printf("%d ",pre[root]);&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;pre[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;in[i]); &#125; post(0,0,n-1); return 0;&#125; 已知先序与中序求层序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int index,value;&#125;; bool cmp(node a,node b)&#123; return a.index&lt;b.index;&#125;vector&lt;node&gt; ans;vector&lt;int&gt; pre,in;void post(int root,int start,int end,int index)&#123;//root是现需遍历数组中的根节点位置 if(start&gt;end) return; int i=start; while(i&lt;end&amp;&amp;in[i]!=pre[root]) i++;//i是中序遍历数组中根节点位置 post(root+1,start,i-1,index*2+1); post(root+1-start+i,i+1,end,index*2+2); ans.push_back(&#123;index,pre[root]&#125;);&#125;int main()&#123; int n; scanf("%d",&amp;n); pre.resize(n); in.resize(n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;pre[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;in[i]); &#125; post(0,0,n-1,0); sort(ans.begin(),ans.end(),cmp); for(int i=0;i&lt;ans.size();i++)&#123; if(i!=0) printf(" "); printf("%d",ans[i].value); &#125; return 0;&#125; 已知后序与中序求先序1234567891011121314151617181920212223242526#include&lt;cstdio&gt;int post[32],in[32];//pre[]是先序遍历数组，in[]是中序遍历数组 void pre(int root,int start,int end)&#123;//root是现需遍历数组中的根节点位置 if(start&gt;end) return; int i=start; while(i&lt;end&amp;&amp;in[i]!=post[root]) i++;//i是中序遍历数组中根节点位置 printf("%d ",post[root]); post(root-1-end+i,start,i-1); post(root-1,i+1,end);&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;post[i]); &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;in[i]); &#125; post(n-1,0,n-1); return 0;&#125; 已知后序与中序求层序1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct node&#123; int index,value;&#125;; bool cmp(node a,node b)&#123; return a.index&lt;b.index;&#125;vector&lt;node&gt; ans;vector&lt;int&gt; post,in;void pre(int root,int start,int end,int index)&#123; if(start&gt;end)&#123; return; &#125; int i=start; while(i&lt;end&amp;&amp;post[root]!=in[i]) i++; ans.push_back(&#123;index,post[root]&#125;); pre(root-1-end+i,start,i-1,2*index+1); pre(root-1,i+1,end,2*index+2);&#125;int main()&#123; int n; scanf("%d",&amp;n); post.resize(n); in.resize(n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;post[i]); for(int i=0;i&lt;n;i++) scanf("%d",&amp;in[i]); pre(n-1,0,n-1,0); sort(ans.begin(),ans.end(),cmp); for(int i=0;i&lt;ans.size();i++)&#123; if(i!=0) cout&lt;&lt;" "; cout&lt;&lt;ans[i].value; &#125; return 0;&#125; 参考文章已知后序与中序输出前序（先序）]]></content>
      <tags>
        <tag>二叉树树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 分页工具————Pageable与Page]]></title>
    <url>%2F2020%2F01%2F05%2FSpring-Data-JPA-%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E2%80%94%E2%80%94Pageable%E4%B8%8EPage%2F</url>
    <content type="text"><![CDATA[预先导入的包import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest; Pageable概述1Page&lt;OrderMaster&gt; findByBuyerOpenid(String buyerOpenid, Pageable pageable); Pageable是Spring Data库中定义的一个接口，用于构造翻页查询，是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关所有信息（例如pageNumber、pageSize等），这样，Jpa就能够通过pageable参数来得到一个带分页信息的Sql语句。PageRequest是Pageable的实现。 接口123456789101112131415161718public interface Pageable &#123; int getPageNumber();//返回要返回的页面 int getPageSize();//返回要返回的项目的数量 long getOffset();//根据底层页面和页面大小返回偏移量 Sort getSort();//返回排序参数 Pageable next(); Pageable previousOrFirst(); Pageable first(); boolean hasPrevious();&#125; Page概述1Page&lt;OrderMaster&gt; result=repository.findByBuyerOpenid(OPENID,request); 用于储存查询的结果集。 接口1234567891011121314151617181920212223242526272829public interface Page&lt;T&gt; extends Iterable&lt;T&gt; &#123; int getNumber(); //当前第几页 返回当前页的数目。总是非负的 int getSize(); //返回当前页面的大小 int getTotalPages(); //返回分页总数 int getNumberOfElements(); //返回当前页上的元素数 long getTotalElements(); //返回元素总数 boolean hasPreviousPage(); //返回如果有上一页 boolean isFirstPage(); //返回当前页是否为第一页 boolean hasNextPage(); //返回如果有下一页 boolean isLastPage(); //返回当前页是否为最后一页 Iterator&lt;T&gt; iterator(); List&lt;T&gt; getContent(); //将所有数据返回为List boolean hasContent(); //返回数据是否有内容 Sort getSort(); //返回页的排序参数&#125; Pageable与Page实例采用单元测试的形式进行实例说明。 1234public interface OrderMasterRepository extends JpaRepository&lt;OrderMaster,String&gt; &#123; Page&lt;OrderMaster&gt; findByBuyerOpenid(String buyerOpenid, Pageable pageable);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142public class OrderMasterRepositoryTest &#123; private Logger logger= LoggerFactory.getLogger(OrderMasterRepositoryTest.class); @Autowired private OrderMasterRepository repository; private final String OPENID="110110"; @Test public void saveTest()&#123;//存储两条数据 OrderMaster orderMaster=new OrderMaster(); orderMaster.setOrderId("123456"); orderMaster.setBuyerName("师兄"); orderMaster.setBuyerPhone("23456789123"); orderMaster.setBuyerAddress("北京"); orderMaster.setBuyerOpenid("110110"); orderMaster.setOrderAmount(new BigDecimal(2.3)); OrderMaster result=repository.save(orderMaster); OrderMaster orderMaster1=new OrderMaster(); orderMaster1.setOrderId("789456"); orderMaster1.setBuyerName("师姐"); orderMaster1.setBuyerPhone("13222222222"); orderMaster1.setBuyerAddress("杭州"); orderMaster1.setBuyerOpenid("110110"); orderMaster1.setOrderAmount(new BigDecimal(6.7)); repository.save(orderMaster1); Assert.assertNotNull(result); &#125; @Test public void findByBuyerOpenid() &#123; //PageRequest request=new PageRequest(0,2);//从第1页开始，每页2个数据;Pageable实现：PageRequest PageRequest request=PageRequest.of(0,2);//此写法为新写法 Page&lt;OrderMaster&gt; result=repository.findByBuyerOpenid(OPENID,request); logger.info(result.toString());//Page 1 of 1(第一页共一页) Assert.assertNotNull(result.getTotalElements()); &#125;&#125;]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 进制转换]]></title>
    <url>%2F2019%2F12%2F27%2Fc-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[任意2-36进制数转换为10进制数以二进制转换为十进制为例：基本规则：把二进制数按权展开、相加即得十进制数。 c++代码实现123456789int toDecimal(string s,int radix)&#123; //s是给定的radix进制字符串 int ans=0; for(int i=0;i&lt;s.size();i++)&#123; char t=s[i]; if(t&gt;='0'&amp;&amp;t&lt;='9') ans=ans*radix + (t-'0'); else ans=ans*radix + (t-'a'+10); &#125; return ans;&#125; Demo12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int toDecimal(string s,int radix)&#123; //将二进制的11011转换为十进制 int ans=0; for(int i=0;i&lt;s.size();i++)&#123; char t=s[i]; if(t&gt;='0'&amp;&amp;t&lt;='9') ans=ans*radix+(t-'0'); else ans=ans*radix+t-'a'+10; &#125; return ans;&#125;int main()&#123; string s="11011"; int radix=2; int res=toDecimal(s,2); //通过to_string()方法将int转换为string //string s1=to_string(res); printf("%d",res); return 0;&#125; 十进制转换为其他进制方法一以十进制转换为二进制为例：基本规则：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除，直到商为0为止。 c++代码实现1234567891011string decimalToA(int n,int radix)&#123;//n是待转数字(十进制)，radix是需转换为的进制 string ans=""; do&#123; int t=n%radix; if(t&gt;=0&amp;&amp;t&lt;=9) ans+=t+'0';//将数字转换为字符 else ans+=t-10+'a';//转换为相应的字母，比如讲十进制的11转换为16进制的b n/=radix; &#125;while(n!=0); //使用do&#123;&#125;while()以防止输入为0的情况 reverse(ans.begin(),ans.end()); return ans; &#125; Demo123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;string decimalToA(int n,int radix)&#123;//将十进制150转换为二进制 string ans=""; do&#123; int t=n%radix; if(t&gt;=0&amp;&amp;t&lt;=9) ans+=t+'0';//将数字转换为字符 else ans+=t-10+'a';//转换为相应的字母，比如讲十进制的11转换为16进制的b n/=radix; &#125;while(n!=0); //使用do&#123;&#125;while()以防止输入为0的情况 reverse(ans.begin(),ans.end()); return ans; &#125; int main()&#123; int n=150; int radix=2; string res=decimalToA(n,2); //可以用stoi()函数将string类型转换为int //int res1=stoi(res.c_str()); printf("%s", res.c_str()); return 0;&#125; 方法二itoa()函数（可以将一个10进制数转换为任意的2-36进制字符串）用法：charitoa(int value,charstring,int radix); Demo123456789101112#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int main()&#123; int num=10; char str[10]; itoa(num, str, 16); //将十进制的10，转换为16进制，并存在字符串str中 printf("%s",str); return 0;&#125;]]></content>
      <tags>
        <tag>基础算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度2 Maximum Subsequence Sum (25 分)]]></title>
    <url>%2F2019%2F10%2F26%2F01-%E5%A4%8D%E6%9D%82%E5%BA%A62-Maximum-Subsequence-Sum-25-%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem DescriptionGiven a sequence of K integers { N​1​​ , N​2​​ , …, N​K​​ }. A continuous subsequence is defined to be { N​i​​ , N​i+1​​ , …, N​j​​ } where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input SpecificationEach input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space. Output SpecificationFor each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input10-10 1 2 3 4 -5 -23 3 7 -21 Sample Output10 1 4 题目类型最大子列问题 参考代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int main() &#123; int A[10010],K=0; cin &gt;&gt;K; //在线处理 int thisSum=0, maxSum=-1;//此处注意，maxSum赋值为-1，否则负数和0通不过 int tempL = 0,left=0,right=K-1; for (int i = 0; i &lt; K; i++) &#123; cin &gt;&gt; A[i]; thisSum += A[i]; if (thisSum &gt; maxSum) &#123;//在线更新 maxSum = thisSum; right = i;//当前子列右侧 left = tempL;//当前子列的左侧 &#125; else if(thisSum&lt;0)&#123;//当前子列是负的，肯定不是最大子列;且可满足最大子列小于零结果置零的条件 thisSum = 0; tempL = i+1;//子列"另起山头"。当前子列左端为i，因此，新子列左端从i+1开始。 &#125; &#125; if (maxSum&lt;0) &#123; cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; A[0] &lt;&lt; " " &lt;&lt; A[K - 1] &lt;&lt; endl; //全为负数，输出第一个和最后一个 &#125; else&#123; cout &lt;&lt; maxSum &lt;&lt; " " &lt;&lt; A[left] &lt;&lt; " " &lt;&lt; A[right] &lt;&lt; endl; //存在最大子列和，正常输出 &#125; return 0;&#125;]]></content>
      <categories>
        <category>浙大数据结构编程练习</category>
      </categories>
      <tags>
        <tag>浙大数据结构编程练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLErrorCodes loaded: [DB2, Derby, H2, HSQL, Informix, MS-SQL, MySQL, Oracle, PostgreSQL, Sybase, Hana]]]></title>
    <url>%2F2019%2F10%2F21%2FSQLErrorCodes-loaded-DB2-Derby-H2-HSQL-Informix-MS-SQL-MySQL-Oracle-PostgreSQL-Sybase-Hana%2F</url>
    <content type="text"><![CDATA[错误描述学习使用SpringMVC框架，在进行数据的插入时出现如下错误: 问题原因哎，问题原因很简单sql传参与该字段在数据库的数据类型不匹配…… 网上其实很多针对于该问题的回答，几乎全是将问题归于字段在数据库的数据类型不匹配，这确实是对的，以SpringMVC为例，我的问题就是由于mapper中的SQL语句里的一个字段与数据库不匹配而造成的。 解决办法 查找sql传参与该字段在数据库的数据类型是不是匹配。 在可视化界面（plsql,navicat）里面执行一下自己的sql是不是有语法错误，可视化界面里面报的错误要比项目日志里面报的明确得多。 SQL语句与数据库中的字段可以相匹配，但是前端js代码中可能存在对非数据库字段进行例如插进数据库等操作，导致该问题的发生，因此还需留意前端代码关于数据的处理。]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度3 二分查找 (20 分)]]></title>
    <url>%2F2019%2F10%2F08%2F01-%E5%A4%8D%E6%9D%82%E5%BA%A63-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-20-%E5%88%86%2F</url>
    <content type="text"><![CDATA[本题要求实现二分查找算法。 函数接口定义：1Position BinarySearch( List L, ElementType X ); 其中List结构定义如下： 123456typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */&#125;; L是用户传入的一个线性表，其中ElementType元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找X在Data中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */&#125;;List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */Position BinarySearch( List L, ElementType X );int main()&#123; List L; ElementType X; Position P; L = ReadInput(); scanf("%d", &amp;X); P = BinarySearch( L, X ); printf("%d\n", P); return 0;&#125;/* 你的代码将被嵌在这里 */ 输入样例1：5 12 31 55 89 101 31 输出样例1：2 输入样例2：3 26 78 233 31 输出样例2：0 参考代码：1234567891011121314151617181920Position BinarySearch( List L, ElementType X )&#123; int max=L-&gt;Last;//最后一个元素的位置赋给max int min=1;//第一个元素的位置，元素从下标1开始 int binaryNum=0; while(min&lt;=max) &#123; binaryNum=(max+min)/2;//进行二分 if(L-&gt;Data[binaryNum]&gt;X)&#123; max=binaryNum-1; &#125;else if(L-&gt;Data[binaryNum]&lt;X)&#123; min=binaryNum+1; &#125;else&#123; return binaryNum; &#125; &#125; return NotFound; &#125;]]></content>
      <categories>
        <category>浙大数据结构编程练习</category>
      </categories>
      <tags>
        <tag>浙大数据结构编程练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO之InputStream OutputStream常用方法说明]]></title>
    <url>%2F2019%2F10%2F06%2FJavaIO%E4%B9%8BInputStream-OutputStream%E7%AE%80%E4%BB%8B-%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[基本含义InputStream:输入字节流，是一个抽象类，包含了读取方法以及辅助方法。 OutputStream:输出字节流，是一个抽象类，包含了写入方法以及辅助方法。 常用方法详解InputStreamread() read() 从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值，如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 方法将会一直阻塞,直到数据可用,检测到流的末尾或者抛出异常。 无参数的read() 是抽象方法,由实现类提供实现。 无参数的read()返回的数据为读取到的字节值，而有参数的则是读取到字节数组中,所以返回值为读取到的个数。 read方法关键点就是要么就是直接返回读取的字节，要么就是将读取到的字节放入字节数组中,字节数组是你传递进去的。close() 关闭流并释放与此流有关的系统资源,可能抛出IOException。 close方法是空方法。 示例代码12345678910111213141516171819202122232425262728public class IO &#123; public static void main(String[] args) throws IOException &#123; File file=new File("C:\\1.txt"); /** * 读取数据 * 为了防止中文乱码，一个汉字需三个字节 */ //输入流读取数据 InputStream inputStream = new FileInputStream(file); int length; byte[] bs = new byte[100];//设置缓冲byte数组接受读取文件内容 //一次读取一个字节 while ((length=inputStream.read(bs))!=-1) &#123;//读取数据存到bs中 System.out.print(new String(bs)); &#125; //关闭IO流 inputStream.close(); //方式二，会导致中文乱码,因为一个中文是三个字节// InputStream inputStream2=new FileInputStream(file);// int i;// while((i=inputStream2.read())!=-1) &#123;//读取的数据存到i中// System.out.println((char)i);// &#125;// inputStream2.close(); &#125;&#125; OutputStreamwrite(int b) 将指定的字节写入此输出流。 虽然参数是int，但写入的是byte。write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流write(byte[] b,int off,int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流,write(b, off, len) 的常规协定是：将数组 b 中的某些字节按顺序写入输出流；元素 b[off] 是此操作写入的第一个字节，b[off+len-1] 是此操作写入的最后一个字节。flush() flush的含义为刷新,在写入数据时使用 之所以需要刷新,是因为有的输出流的写方法实现,可能已经缓冲了以前写入的任何字节,那么,这个方法用于提供能够立即将数据写入到磁盘的功能,不过,只是立即请求操作系统进行处理,而不保证这些字节实际已经写入到物理设备,比如磁盘。示例代码1234567891011121314151617public class IO &#123; public static void main(String[] args) throws IOException &#123; File file=new File("C:\\1.txt"); /** * 写入数据 */ //输出流写入数据,没有指定文件则创建 OutputStream outputStream = new FileOutputStream(file); // 写入数据 byte[] datas="你好".getBytes(); outputStream.write(datas); outputStream.flush();//内存中数据刷新到硬盘 // 关闭IO流 outputStream.close(); &#125;&#125; 运用字节流，复制文件示例代码123456789101112131415161718public class IO &#123; public static void main(String[] args) throws IOException &#123; /** * 复制文件 */ FileInputStream inputStream=new FileInputStream("C:\\1.txt"); FileOutputStream outputStream=new FileOutputStream("C:\\2.txt"); int i=0; while((i=inputStream.read())!=-1) &#123; outputStream.write(i); &#125; inputStream.close(); outputStream.flush(); outputStream.close(); System.out.println("复制完毕")&#125; 参考文章：JavaIO之InputStream OutputStream简介 方法列表说明]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-线性结构1 两个有序链表序列的合并 (15 分)]]></title>
    <url>%2F2019%2F10%2F01%2F02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%841-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%88%E5%B9%B6-15-%E5%88%86%2F</url>
    <content type="text"><![CDATA[本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。 函数接口定义：1List Merge( List L1, List L2 ); 其中List结构定义如下： 123456typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */ L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。 裁判测试程序样例：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read(); /* 细节在此不表 */void Print( List L ); /* 细节在此不表；空链表将输出NULL */List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;/* 你的代码将被嵌在这里 */ 输入样例：3 1 3 5 5 2 4 6 8 10 输出样例：1 2 3 4 5 6 8 10 NULL NULL 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546List Merge( List L1, List L2 )//List为指针变量&#123; List p1 = L1 -&gt; Next, p2 = L2 -&gt; Next;//注意链表是带头结点的 List L3 = (List)malloc(sizeof(struct Node));//动态内存分配，L3为链表头指针。 L3 -&gt; Next = NULL; List p = L3;//p指针向后，使两条链表联立在一起 while(p1 &amp;&amp; p2)&#123; if( p1 -&gt; Data &lt;= p2 -&gt; Data )&#123; List temp = (List)malloc(sizeof(struct Node));//注意在c语言中结构体引用是struct Node；List为指针变量 temp -&gt; Data = p1 -&gt; Data; temp -&gt; Next = NULL; p -&gt; Next = temp; p = temp; p1 = p1 -&gt; Next; &#125;else&#123; List temp = (List)malloc(sizeof(struct Node)); temp -&gt; Data = p2 -&gt; Data; temp -&gt; Next = NULL; p -&gt; Next = temp; p = temp; p2 = p2 -&gt; Next; &#125; &#125; if( p1 ) while( p1 )&#123; List temp = (List)malloc(sizeof(struct Node) ); temp -&gt; Data = p1 -&gt; Data; temp -&gt; Next = NULL; p -&gt; Next = temp; p = temp; p1 = p1 -&gt; Next; &#125; if( p2 ) while( p2 )&#123; List temp = (List)malloc(sizeof(struct Node)); temp -&gt; Data = p2 -&gt; Data; temp -&gt; Next = NULL; p -&gt; Next = temp; p = temp; p2 = p2 -&gt; Next; &#125; L1-&gt;Next = NULL;//链表合并后，原链表置空 L2-&gt;Next = NULL; return L3;&#125;]]></content>
      <categories>
        <category>浙大数据结构编程练习</category>
      </categories>
      <tags>
        <tag>浙大数据结构编程练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-复杂度1 最大子列和问题 (20 分)]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述：给定K个整数组成的序列{ N1, N2 , …, N​k }，“连续子列”被定义为{ Ni, N​i+1, …, Nj}，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性； 数据2：102个随机整数； 数据3：103个随机整数； 数据4：104个随机整数； 数据5：105个随机整数； 输入格式:输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。 输出格式：在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例：6 -2 11 -4 13 -5 -2 输出样例：20 说明：此题选自中国大学MOOC上浙大数据结构的编程练习题目，本文将提供针对此题的三种解法（C++）。 解法一：思路： 确立数组中的两个脚标i,j； 确立一个变量temp，temp值在i与j之间； 求得脚标为i到temp的数组元素的和； 以上为一个过程，分别枚举i和j即为全过程。时间复杂度：O(n3)参考代码：1234567891011121314151617181920212223242526#include&lt;cstdio&gt;const int maxn = 100010;int main() &#123; int k, a[maxn] = &#123;0&#125;, temp; int thisSum = 0, maxSum = 0; scanf("%d", &amp;k); for (int k1 = 0; k1 &lt; k; k1++) &#123;//读入数组中的值 scanf("%d", &amp;a[k1]); &#125; for (int i = 0; i &lt; k; i++) &#123;//枚举 for (int j = i; j &lt; k; j++) &#123;//枚举a[i]之后的元素 thisSum = 0;//记录a[i]~a[j]之间子列和 for (temp = i; temp &lt;= j; temp++) &#123;//temp为a[i]~a[j]之间的值 thisSum += a[temp]; &#125; if (thisSum &gt; maxSum) &#123;//交换 maxSum = thisSum; &#125; &#125; &#125; printf("%d", maxSum); return 0;&#125; 解法二：思路： 确立一个脚标i，确立一个变量j； j的值从i一直到数组的长度对应的值（k）进行枚举； 每一次枚举求一次脚标i到脚标j的数组元素值的和； 最后枚举i。时间复杂度：O(n2)参考代码：12345678910111213141516171819202122232425#include&lt;cstdio&gt;const int maxn = 100100;int main() &#123; int k, a[maxn] = &#123; 0 &#125;, temp; int thisSum = 0, maxSum = 0; scanf("%d", &amp;k); for (int k1 = 0; k1 &lt; k; k1++) &#123; scanf("%d", &amp;a[k1]); &#125; for (int i = 0; i &lt; k; i++) &#123; thisSum = 0; for (int j = i; j &lt; k; j++) &#123; thisSum += a[j]; if (maxSum &lt; thisSum) &#123; maxSum = thisSum; &#125; &#125; &#125; printf("%d", maxSum); return 0;&#125; 解法三：在线处理思路： 枚举变量i； 时刻判断当前子列和是否为负，若当前子列和为负数，不可能后面的部分增大，所以此时应另起锅灶，下一个元素定为新子列的第一个元素。时间复杂度：O(n2)参考代码：123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;cstdio&gt;const int maxn = 100100;int main() &#123; int k, a[maxn] = &#123; 0 &#125;, temp; int thisSum = 0, maxSum = 0; scanf("%d", &amp;k); for (int k1 = 0; k1 &lt; k; k1++) &#123; scanf("%d", &amp;a[k1]); &#125; for (int i = 0; i &lt; k; i++) &#123; thisSum += a[i]; if (maxSum &lt; thisSum) &#123; maxSum = thisSum; &#125; else if (thisSum &lt; 0) &#123;//当前子列和为负数 thisSum = 0;//不可能后面的部分增大，因此抛弃，将子列和归零，接着计算 &#125; &#125; printf("%d", maxSum); return 0;&#125;]]></content>
      <categories>
        <category>浙大数据结构编程练习</category>
      </categories>
      <tags>
        <tag>浙大数据结构编程练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Animation与Animator的创建]]></title>
    <url>%2F2019%2F09%2F26%2FUnity-Animation%E4%B8%8EAnimator%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Animation与Animator的差异：Animation:是历史遗留下来的版本，专用于做简单动画。只支持控制一个动画的播放。Animator:有一个动画控制器，俗称动画状态机，是5.X之后新设计的版本，用于复杂动画的控制。 Animator的创建：方法一： 首先，创建一个Cube对象，接着，按路径Window-&gt;Animation-&gt;Animation查找Animation视图，打开Animation视图，然后，选中Cube对象，此时在Animation视图中出现如下提示： 点击Create进行Animator的创建，创建完毕后，在Project视图中可看到，刚刚创建的Animator（Cube）与Animation(New Animation)： 点击New Animation查看属性(此处留意，通过Animator创建的Animation与Animation属性有所不同，单单Animation的创建将在后文进行演示)： 点击Cube查看Cube属性，可以看到Animator已经创建好了： 方法二：点击Cube查看属性，在Inspector界面中点击Add Component，查找Animator进行创建： 点击Cube，在Animation界面中点击Create进行Animator的创建，查看Project列表，刚刚创建的Animator（Cube）与Animation(New Animation)。 Animation创建：点击Cube查看属性，在Inspector界面中点击Add Component，查找Animation进行创建： 点击Cube，在Animation界面中点击Create进行Animaton的创建: 查看Project列表，此时列表中只有Animation(New Animation)： 再次，点击Project列表中的New Animation查看其属性： 可以看到，通过Animation创建的Animation与通过Animator创建的Animation的属性是不同的。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>Animator</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-server报错：Could not create server TCP listening socket *:6379 问题的解决]]></title>
    <url>%2F2019%2F09%2F15%2Fredis-server%E6%8A%A5%E9%94%99%E5%9C%B0%E5%9D%80%E8%A2%AB%E5%8D%A0%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题描述： 问题解决：输入指令ps -ef | grep -i redis检测后台进程： 通过指令kill -9 1473终止1473进程。 这时，问题就已经解决了，重新运行服务器： 此时已经可以正常运行服务器了。]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用secureCRT对Linux进行文件上传与删除操作]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%BD%BF%E7%94%A8secureCRT%E4%B8%8A%E4%BC%A0%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%88%B0linux%2F</url>
    <content type="text"><![CDATA[使用secureCRT上传文件至linux服务器 以SSH2的连接方式，通过secureCRT连接到Linux服务器。 在终端使用快捷键Alt+p，打开sftp连接窗口。 拖动需上传的文件到该窗口即可。但要注意的一点是，默认上传的位置是根目录。例如我们将一个本地文件1.txt进行上传，将出现如下效果： 上传文件到指定linux指定目录下(以home目录为例)，先在sftp连接窗口中进入目录： 进行上传操作： 结果： 使用secureCRT删除linux服务器上的文件与在linux服务器上的删除操作相同通过指令rm 文件名即可，例如，删除刚刚上传的1.txt文件：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>secureCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 字符串的输入输出处理]]></title>
    <url>%2F2019%2F09%2F07%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目描述：字符串的输入输出处理。 输入：第一行是一个正整数N，最大为100。之后是多行字符串（行数大于N）， 每一行字符串可能含有空格，字符数不超过1000。 输出：先将输入中的前N行字符串（可能含有空格）原样输出，再将余下的字符串（不含有空格）以空格或回车分割依次按行输出。每行输出之间输出一个空行。 输入样例：2 www com A C M A B D CPP 样例输出：www com A C M D O T CPP 注意事项： 注意缓存区的回车符号读取。 输出每一行字符串后都要换一次换行。 cin&gt;&gt; 是会过滤掉不可见字符（如 空格 回车，TAB 等）。 cin&gt;&gt;遇到空字符（包括回车，TAB，空格）都会当成一个输入的结束。参考代码：123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cin.get();//读取缓存区的回车符号 string str[100];//字符串数组，接收应原样输出的字符串 string s;//接收应换行输出的字符串 for(int i=0;i&lt;n;i++)&#123; getline(cin,str[i]); cout&lt;&lt;str[i]&lt;&lt;endl&lt;&lt;endl; &#125; while(cin&gt;&gt;s)&#123; cout&lt;&lt;s&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯 字符串处理</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 求N内的素数]]></title>
    <url>%2F2019%2F08%2F31%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%20N%E5%86%85%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述：用筛法求之N内的素数。 输入：N 输出：0～N的素数 样例输入：100 样例输出：2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 素数定义：素数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 参考代码：12345678910111213141516171819#include&lt;cstdio&gt;int main()&#123; int n,i,j; scanf("%d",&amp;n); int flag;//flag为1，代表是素数；为0，代表非素数。 for(i=2;i&lt;=n;i++)&#123; flag=1; for(j=2;j&lt;=i/2;j++)&#123; if(i%j==0) &#123; flag=0; &#125; &#125; if(flag==1)&#123; printf("%d\n",i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯 素数</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1033 旧键盘打字 (20 分)]]></title>
    <url>%2F2019%2F08%2F20%2FB1033%2F</url>
    <content type="text"><![CDATA[题目描述：旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。 注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：7+IE. 7_This_is_a_test. 输出样例：_hs_s_a_tst 题目分析：散列问题 思路： 设置bool类型变量hashTable[128]，表示字符是否完好，初值设置为true，全部完好，在读入第一行字符串是时，将其出现的字符变为false。 将大写字母转化为小写字母。 遍历第二行字符串，如果hashTable数组中对应的值为true（有效），且有hashTable[+]为true，则可输出大写字母；如果只是hashTable数组中对应的值为true（有效），则只能输出小写字母。参考代码：12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 100010;bool HashTable[128];char str[maxn];int main() &#123; memset(HashTable,true,sizeof(HashTable));//所有键都没问题 fgets(str, 100010, stdin); int len = strlen(str); for (int i = 0; i &lt; len; i++) &#123; if (str[i] &gt;= 'A'&amp;&amp;str[i] &lt;= 'Z') &#123; str[i] = str[i] + 32; &#125; HashTable[str[i]] = false; &#125; fgets(str, 100010, stdin); len = strlen(str); for (int i = 0; i &lt; len; i++) &#123; if (str[i] &gt;= 'A'&amp;&amp;str[i] &lt;= 'Z') &#123; int low = str[i] + 32; if (HashTable[low] == true &amp;&amp; HashTable['+'] == true) &#123; printf("%c", str[i]); &#125; &#125; else if (HashTable[str[i]] == true) &#123; printf("%c", str[i]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1029 旧键盘 (20 分)]]></title>
    <url>%2F2019%2F08%2F20%2FB1029%2F</url>
    <content type="text"><![CDATA[题目描述旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 输入格式：输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。 输出格式：按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 输入样例：7_This_is_a_test _hs_s_a_es 输出样例：7TI 题目分析：散列问题 思路： 设置一个bool型的数组HashTable[128]表示字符是否坏掉. 枚举输入样例第一行的每一个字符，与第二行进行枚举比较，如果某一个字符被输出，则说明该字符没有问题。 注意点： 小写字母的ASCII值比其对应的大写字母大32。 ASCII值规定了128个因此哈希表大小定义为128个。 小写字母输出为其对应的大写形式。 参考代码：12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;int main() &#123; char str1[100], str2[100]; bool HashTable[128] = &#123; false &#125;;//ASCII定义了128个字符,记录是否已经输出 fgets(str1, 100, stdin); fgets(str2, 100, stdin); int len1 = strlen(str1); int len2 = strlen(str2); for (int i = 0; i &lt; len1; i++) &#123; int j; char c1, c2; for ( j = 0; j &lt; len2; j++) &#123; c1 = str1[i]; c2 = str2[j]; if (c1 &gt;= 'a'&amp;&amp;c1 &lt;= 'z') c1 -= 32; if (c2 &gt;= 'a'&amp;&amp;c2 &lt;= 'z') c2 -= 32; if (c1 == c2) break; &#125; if (j == len2 &amp;&amp; HashTable[c1] == false) &#123; printf("%c", c1); HashTable[c1] = true; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中JPA扩展查询]]></title>
    <url>%2F2019%2F08%2F12%2FSpringboot%E4%B8%ADJPA%E6%89%A9%E5%B1%95%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[前言JPA的出现，使得在开发过程中，几乎不需要写什么sql语句，便可完成对数据的增删改查。但是，其查询功能有时并不能完全满足我们的需求，因此，就需要开发者基于JPA进行扩展查询，本文将结合一个小案例来阐述Springboot中JPA扩展查询的使用。 添加依赖12345678&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 建立一个实体类123456789101112131415161718192021222324252627import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import java.math.BigDecimal;@Entity@Datapublic class ProductInfo &#123; @Id private String productId; private String productName; private BigDecimal productPrice; private Integer productStock; private String productDescription; private String productIcon; private Integer categoryType; private Integer productStatus;&#125; 进行查询将产品状态（productStatus）作为关键字进行查询。 12345678import com.imooc.sell.dataobject.ProductInfo;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;public interface ProdctInfoRepository extends JpaRepository&lt;ProductInfo,String&gt; &#123;//&lt;对象，主键类型&gt; List&lt;ProductInfo&gt; findByProductStatus(Integer productStatus);&#125; 注意findByProductStatus这并不是随便的一个变量名，findBy格式是固定的，后面的ProductStatus和实体类中的属性要一一对应。 测试代码@RunWith(SpringRunner.class) @SpringBootTest public class ProdctInfoRepositoryTest { @Autowired private ProdctInfoRepository repository; @Test public void findByProductStatus() {//根据产品状态进行查询 List&lt;ProductInfo&gt; productInfoList=repository.findByProductStatus(1);//0是上架 Assert.assertNotEquals(0,productInfoList.size()); } } JPA扩展查询语句结构]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1046 Shortest Distance (20 point(s))]]></title>
    <url>%2F2019%2F08%2F11%2FA1046%2F</url>
    <content type="text"><![CDATA[Problem DescriptionThe task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,106]), followed by N integer distances D1D2…Dn​​ , where Di​​ is the distance between the i-th and the (i+1)-st exits, and DN​​ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107​. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input:5 1 2 4 14 9 3 1 3 2 5 4 1 Sample Output:3 10 7 题目大意：N个节点围成一个圈，给定相邻节点的距离，求两节点之间的最小距离 样例分析：在输入样例中，第一行第一个数字，代表着有几个节点围成的一个圈，第一行的其他数字，表示12,23，…n-1~n节点之间的距离。 第二行中的数字N，表示接下来会给N对节点。 剩余的N行表示，具体需求出距离的的节点对。 在输出样例中， 输出N行节点之间的最短距离。 思路： 在一个圈中，两节点的距离无非是顺时针，逆时针两种情况，这两者中较小的距离，便是所需求的最短距离 定义一个变量sum来存放一周总距离，在定义一个数组dis[i]存放第一点到第i点的距离。 假设给定的两点分别为i1与i2,且保证若前者大于后者则交换，则两点之间顺时针的距离为dis[i2-1]-dis[i1-1]。 比较顺时针距离(dis[i2-1]-dis[i1-1])与逆时针距离(sum-dis[i2-1]-dis[i1-1])取较小的一个即可。参考代码：1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=100010;int dis[MAXN],A[MAXN];//dis[]数组存放1到i顺时针距离int main()&#123; int sum=0,n,left,right; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;A[i]); sum+=A[i]; dis[i]=sum; &#125; int query; scanf("%d",&amp;query); for(int i=0;i&lt;query;i++)&#123; scanf("%d %d",&amp;left,&amp;right); if(left&gt;right)swap(left,right); int temp=dis[right-1]-dis[left-1]; printf("%d\n",min(temp,sum-temp)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1042 Shuffling Machine (20 point(s))]]></title>
    <url>%2F2019%2F08%2F10%2FA1042%2F</url>
    <content type="text"><![CDATA[Problem DescriptionShuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2 where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input:2 36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output:S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 题目大意：五十四张扑克牌，初始序列为S1, S2, …, S13, H1, H2, …, H13,C1，C2, …, C13, D1, D2, …, D13, J1, J2。（S,H,C,D,J分别代表花色）将给定一个数组，数组中的数字，为洗牌后，牌放置的位置。如，有五张牌 S3, H5, C1, D13 和 J2. 给一个序列{4, 2, 5, 3, 1}, 则结果为 J2, H5, D13, S3, C1.再次按照，序列洗牌，则变为C1, H5, S3, J2, D13。 思路： 先不做牌的花色以及牌序号的区分，只给54个编号1~54。 设置三个数组start[], end[], next[],第一个数组存放初始的元素，第二个数组放置排序后的元素，第三个数组存放排序的序列。next[i ]中的元素作为脚标放在end中，再把start[i]的值赋给即可。 处理对应花色，与数字的关系。设数组mp{}={S,H,C,D,J}当前的牌号是x则对应的花色为mp[(x-1)/13],数字为(x-1)%13+1.参考代码：12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;const int N = 54;int start[N + 1], end[N + 1], next[N + 1];char mp[5] = &#123; 'S','H','C','D','J' &#125;;int main() &#123; int k; scanf("%d", &amp;k); for (int i = 1; i &lt;= N; i++) &#123; start[i] = i; &#125; for (int i = 1; i &lt;= N; i++)&#123; scanf("%d", &amp;next[i]); &#125; for (int step = 0; step &lt; k; step++) &#123; for (int i = 1; i &lt;= N; i++) &#123; end[next[i]] = start[i]; &#125; for (int i = 1; i &lt;=N; i++)&#123; start[i] = end[i]; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; if (i != 1) printf(" "); start[i]--; printf("%c%d", mp[start[i] / 13], start[i]% 13+1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1001 A+B Format (20 point(s))]]></title>
    <url>%2F2019%2F08%2F10%2FA1001%2F</url>
    <content type="text"><![CDATA[Problem DescriptionCalculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where -106 ≤a,b≤106. the numbers are separated by a space.-106 Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:-1000000 9 Sample Output:-999,991 题目大意：给出a,b两个整数，要求求和，并按格式输出。输出的格式为，数字三个为一组，组与组之间通过,隔开。 思路：加和之后,先输出符号，然后取绝对值。将数字按从低到高的位数存放到数组中。输出时，从高位到低位输出，要注意每三位一个逗号，且最后一位除外。 参考代码：1234567891011121314151617181920212223242526#include&lt;cstdio&gt;int main() &#123; int a, b, sum; int num[10]; scanf("%d %d", &amp;a, &amp;b); sum = a + b; if (sum &lt; 0) &#123; printf("-"); sum = -sum; &#125; int len = 0; if (sum == 0) num[len++] = 0; while (sum) &#123; //依次将最低位放在num[0],num[1],num[2]....中 num[len++] = sum % 10; sum /= 10; &#125; for (int k = len - 1; k &gt;= 0; k--) &#123; printf("%d", num[k]); if (k &gt; 0 &amp;&amp; k % 3 == 0)printf(","); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1003 我要通过！ (20 point(s))]]></title>
    <url>%2F2019%2F08%2F10%2FB1003%2F</url>
    <content type="text"><![CDATA[题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例：8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA 输出样例：YES YES YES YES NO NO NO NO 题目分析给出若干字符串，判断答=答案是否正确，正确则输出”YES”,错误则输出”NO”。评判规则如下： 出现P、A、T之外的字符，输出”NO”;P在T左面，P和T之间至少有一个A，否则输出”NO”。 如xPATx格式输出”YES”，x代表空字符串，或由若干个A组成的字符串，如，PAT,APATA,AAPATAA…. 假设有一个字符串格式是aPbTc,这里的a、b、c可以为空，或者是任意数目的A。如果”aPbTc”是YES，则aPbATca也是YES。如，条件二中PAT,APATA,AAPATAA….是YES，则PAAT、APAATAA AAPAATAAAA也是YES。 思路：记录字符P与字符T的数目与位置，并在输入时，判断其他字符是否是A，若其他字符不是A或P的数目不为1或T的数目不为1或P在T右侧则直接NO； 在题目分析中，可以发现条件三其实是条件二的特例，也就是说条件三其实是可以后推到条件而得，条件二有一个特点则是P与T之间只有一个A，且P的左侧与T的右侧A的数目相同。 因此，我们设字符串P左侧的A的数目为x，P、T中间A数目为y，T右侧A数目为z。 回推次数 x y z 1 x y-1 z-x 2 x y-2 z-2x n x y-n z-nx y-1 x 1 z-(u-1)x 回推y-1次，则中间A的数目为1，若此时格式与条件二格式相同，即z-(u-1)x与x相等，就说明条件三通过。因为条件三是条件二的延伸特例，因此，不需要单独判断条件二。 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; char str[110]; scanf("%s", str); int len = strlen(str); int num_p = 0, num_t = 0, other = 0; int pos_p = -1, pos_t = -1; for (int i = 0; i &lt; len; i++) &#123; if (str[i] == 'P') &#123; num_p++; pos_p = i; &#125; else if (str[i] == 'T') &#123; num_t++; pos_t = i; &#125; else if (str[i] != 'A')other++; &#125; if ((num_p != 1) || (num_t != 1) || (other != 0) || (pos_t - pos_p &lt;= 1)) &#123; printf("NO\n"); continue; &#125; //x,y,z分别为P左侧A数，P中间A数，P右侧A数 //注意是从零开始的 int x = pos_p, y = pos_t - pos_p - 1, z = len - pos_t - 1; if (z - (y - 1)*x == x) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1015 德才论 (25 point(s))]]></title>
    <url>%2F2019%2F08%2F10%2FB1015%2F</url>
    <content type="text"><![CDATA[题目描述宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤106），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例：12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 题目分析：输入样例第一行给出考生数N，德才录取最低分L，德才优先录取分H。随后给出每一位考生的准考证号，德分以及才分。通过考生信息科将考生分为5类： 第一类，德才分均不低于H 第二类，德分不低于H，才分低于H 第三类，德才分均低于H，高于L，德分不低于才分 第四类，德才分均低于H，高于L，德分低于才分 第五类，不及格生，才分或德分有一个低于L 对考生的排序按如下规则 先按类别排序 类别相同，按总分排序 总分相同，按德分排排序 德分相同，按准考证号排序 最后输出所有及格生的排名 思路：先定义一个考生结构体，来存储考学生信息；写cmp函数来对考生进行规则排序 参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Student&#123; char id[10]; int de, cai, sum; int flag;//区分为第几类&#125;stu[100010];bool cmp(Student a, Student b) &#123; if (a.flag != b.flag) return a.flag &lt; b.flag;//类别小的在前 else if (a.sum != b.sum) return a.sum &gt; b.sum;//总分打的在前 else if (a.de != b.de)return a.de &gt; b.de;//总分大的在前 else if (a.id != b.id) return strcmp(a.id, b.id) &lt; 0;//学号在前的优先&#125;int main() &#123; int n, l, h; scanf("%d %d %d", &amp;n, &amp;l, &amp;h); int m = n; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", stu[i].id, &amp;stu[i].de, &amp;stu[i].cai); stu[i].sum = stu[i].de + stu[i].cai; if (stu[i].de &lt; l || stu[i].cai &lt; l) &#123; stu[i].flag = 5; m--; &#125; else if (stu[i].de &gt;= h &amp;&amp; stu[i].cai &gt;= h) stu[i].flag = 1; else if (stu[i].de &gt;= h &amp;&amp; stu[i].cai &lt; h) stu[i].flag = 2; else if (stu[i].de &gt;= stu[i].cai ) stu[i].flag = 3; else stu[i].flag = 4; &#125; sort(stu, stu + n, cmp); printf("%d\n", m); for (int i = 0; i &lt; m; i++) &#123; printf("%s %d %d\n", stu[i].id, stu[i].de, stu[i].cai); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot注解详解]]></title>
    <url>%2F2019%2F08%2F08%2FSpringBoot%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解的含义 Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。 这是比较官方的说法。于我而言，我更倾向于把注解理解成代码的标签,其作用就是对对象进行某些角度解释。 注解对于Springboot的重要性注解是springboot的核心内容，在springboot中，通过各种组合注解，极大地简化了spring项目的搭建和开发。因此，我们需要知道主键的基本概念以及使用方法，才能够更加理解Springboot框架。 注解分类1.按照声明周期 源码注解（仅在.java文件中存在，经过编译就不存在了） 编译时注解（在编译时起作用，即在.class文件中也仍然存在） 运行时注解（在运行阶段起作用，有时会影响程序的运行逻辑） 2.按照来源 JDK自带的注解 第三方框架注解 自定义注解 3.元注解 对注解进行注解的注解 注解列表 @Autowired自动导入依赖的bean。 @Bean：产生一个bean,并交给spring管理。相当于XML中配置的bean。 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。可配合CommandLineRunner使用，在程序启动后执行一些基础任务。 @ComponentScan组件扫描，可自动发现和装配一些Bean。 @Configuration等同于spring的XML配置文件；使用Java代码可以检查类型安全。 @Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。 @EnableAutoConfiguration自动配置。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。 @Import：用来导入其他配置类。 @ImportResource：用来加载xml配置文件。 @Inject：等价于默认的@Autowired，只是没有required属性； @JsonBackReference解决嵌套外链问题。 @JsonProperty此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name： 12@JsonProperty("name")private String trueName; @PathVariable获取参数。 @Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者， @Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。 @RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。 @RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。 @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。 @Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。 @RestController是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。 @Service：一般用于修饰service层的组件 @SpringBootApplication包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。 @Value：注入Spring boot application.properties配置的属性的值。 核心注解详解：@SpringBootApplication申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。示例代码： 12345678910package com.example.myproject; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码： 12345@RequestMapping(“/test”) @ResponseBody public String test()&#123; return "index"; &#125; @Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码： 12345678910@Controller@RequestMapping("/hello")public class HelloController &#123; @GetMapping("/say/&#123;id&#125;") public String say()&#123; //返回index.html return "index"; &#125;&#125; @RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码： 1234567891011@RestController@RequestMapping("/hello")public class HelloController &#123; @GetMapping("/say/&#123;id&#125;") public String say(@RequestParam(value = "id",required = false,defaultValue = "0") Integer id)&#123; return "id:"+id; &#125;&#125; JPA注解需先在Maven中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; @Column：如果字段名与列名相同，则可以省略。 @Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略 @GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。 @Id：表示该属性为主键。 @JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。 @JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。 @MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。 @NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。 @OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。 @SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。 @Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式 springMVC相关注解 @PathVariable:路径变量，示例代码1234RequestMapping(“user/get/mac/&#123;macAddress&#125;”) public String getByMacAddress(@PathVariable String macAddress)&#123; //do something; &#125; 参数与大括号里的名字一样要相同。 @RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 @RequestParam：用在方法的参数前面。示例代码： 12@RequestParam String a =request.getParameter(“a”)。 全局异常处理: @ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。 @ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。 参考文章：Spring Boot 注解—基本知识SpringBoot注解最全详解(整合超详细版本)[springBoot系列]–springBoot注解大全]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1048 数字加密 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F06%2FB1048%2F</url>
    <content type="text"><![CDATA[题目描述：本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入案例：1234567 368782971 输出案例：3695Q8118 题目分析：简单的字符串处理问题。对于输入案例，字符串读入的时候是a[0]=’1’,a[1]=’2’….,但是，1234567的个位数字是7，题目要求令个位为第一位。因此，需要反转两次字符串，第一次是在，进行奇偶位数操作时；第二次，是在输出的时，转化字符串，使个位在字符串最右侧。 思路： 比较两字符串长度，选择较长的长度，作为循环上限。 分情况处理，奇偶位不同操作（这里的奇偶位与数组脚标的奇偶是相反的）。 注意两次字符串的反转。 参考代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 110;char a[maxn], b[maxn], ans[maxn];void reverse(char s[]) &#123;//反转字符 int len = strlen(s); char temp; for (int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125;int main() &#123; scanf("%s %s", a, b); reverse(a); reverse(b); int lenA = strlen(a); int lenB = strlen(b); int len = lenA &gt; lenB ? lenA : lenB; for (int i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? a[i] - '0' : 0;//字符转化为整数，超过长度，零来补位 int numB = i &lt; lenB ? b[i] - '0' : 0; if (i % 2 == 0) &#123;//i为偶数，奇数位 int temp = (numA + numB) % 13; if (temp == 10)ans[i] = 'J'; else if (temp == 11)ans[i] = 'Q'; else if (temp == 12)ans[i] = 'K'; else ans[i] = temp + '0';//转换为字符 &#125; else &#123; int temp = numB - numA; if (temp &lt; 0) temp += 10; ans[i] = temp + '0';//转换为字符 &#125; &#125; reverse(ans);//反转字符串 puts(ans); return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Spring-Data-Jpa连接MySQL,并操作数据库]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%80%9A%E8%BF%87Spring-Data-Jpa%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[版本MySQL：5.7.27 jdk：12.0.1 Navicat：12.0.20 IDEA：2018.2.4 具体操作1. 引入依赖spring-boot-starter-data-jpa与mysql-connector-java 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; Springboot自动帮我们选择了版本。所以，在这个位置，不必手动选择版本。 2. 新建数据库命名为test，具体格式如下图所示。（Character set与Collation的选择是为了后续项目进行所需，读者可根据所需自行选择。当然，对于仅连接连接MySQL而言，就算全为默认也是可以的。） 3. 写配置 12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: create show-sql: true 要注意url中，要添加时域serverTimezone=UTC，否则，可能报错Unable to create requested service [org.hibernate.engine.jdbc.env.spi.JdbcEnvironment] 4. 建表表中含有id，money，producer，consumer四个字段新建一个类 test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.lu.test;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import java.math.BigDecimal;@Entitypublic class test &#123; @Id @GeneratedValue private Integer id; private BigDecimal money; private String producer; private String consumer; public test() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public BigDecimal getMoney() &#123; return money; &#125; public void setMoney(BigDecimal money) &#123; this.money = money; &#125; public String getProducer() &#123; return producer; &#125; public void setProducer(String producer) &#123; this.producer = producer; &#125; public String getConsumer() &#123; return consumer; &#125; public void setConsumer(String consumer) &#123; this.consumer = consumer; &#125;&#125; 运行之后，出现如下信息： Hibernate: drop table if exists hibernate_sequence Hibernate: drop table if exists luckymoney Hibernate: create table hibernate_sequence (next_val bigint) engine=MyISAM Hibernate: insert into hibernate_sequence values ( 1 ) Hibernate: create table luckymoney (id integer not null, consumer varchar(255), money decimal(19,2), producer varchar(255), primary key (id)) engine=MyISAM返回到。数据库便可以看到，已经建好了一个名为test的表。 5. 更新表中的内容在数据库中，向新建的表输入内容并保存之后，返回IDEA再次运行代码，则，springboot会重新建一个名为test表，并覆盖旧表，清空旧表数据。 因此，在建好表后，需要更新数据，则应先返回到配置文件中，将 ddl-auto: create更改为ddl-auto: update，这样，在下一次运行IDEA时，才会保留数据库表中的信息。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1024 科学计数法 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F03%2FB1024%2F</url>
    <content type="text"><![CDATA[题目描述：科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 输入格式：每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 输出格式：对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 输入样例 1：+1.23400E-03 输出样例 1：0.00123400 输入样例 2：-1.2E+10 输出样例 2：-12000000000 题目分析：给定一组用科学计数法表示的数字，要求将其转化为正常表示数字，并输出. 思路： 先输出字符串正负，正号不输出，符号正常输出。 扫描字符串，找到E，E相当于分隔符，左侧为小数部分，右侧为指数部分。 指数小于零，小数点往左移，输出0.000…xxxx。 指数大于零，小数点往右移，有两种情况。 第一种情况：小数点移完，数字还是小数x…xx . x..xx。 第二种情况：小数点移完，数字变为整数xxxxx…xxxx或者xxxx…xxx00000。 指数为零，直接输出小数部分。 注意点 使用fgets()接受输入，是其字符串长度是strlen(s)-1。 注意数字存储长度，题目中说数字存储长度不超过9999Byte，而一个字符是1Byte，所以不超过9999字符。 要考虑指数为零的情况。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;int const maxn = 10010;//一个char类型的为一个字节，长度不超过9999个字符，因此选择10010int main() &#123; int i = 0; char s[maxn]; fgets(s, maxn, stdin); int pos = 0;//记录E的位置，E后为指数，前为普通数字 while (s[i]!='E') &#123; i++; &#125; pos = i; //输出正负号 if (s[0] == '+') printf(""); else if (s[0] == '-')printf("-"); int len = strlen(s)-1; int exp = 0;//exp中存储指数 for (i = pos + 2; i &lt; len; i++) &#123;//因为E的位置为pos而E后的一个为正负号，所以第一个数字式pos+2 exp = exp * 10 + (s[i] - '0'); &#125; //如果指数是零，直接输出 if (exp == 0) &#123; for (i = 1; i &lt; pos; i++) &#123; printf("%c", s[i]); &#125; &#125; //指数小于零先输出0，再输出exp-1个零。再输出数字，但是数字不能有小数点 if (s[pos+1] =='-') &#123; printf("0."); for (i = 0; i &lt; exp - 1; i++) &#123; printf("0"); &#125; printf("%c", s[1]); for (i = 3; i &lt; pos; i++) &#123; //if (s[i] == '.') continue;//遇到小数点则跳过 printf("%c", s[i]); &#125; &#125; //输出指数大于零 else &#123; for (i = 1; i &lt; pos; i++) &#123; if (s[i] == '.') continue; printf("%c", s[i]);//输出数字 //添加小数点,加在exp+2位置 //科学计数法中，小数位数为pos-3，小数点移动的位数(exp)等于小数位数不加小数点 if (i == exp + 2 &amp;&amp; pos - 3 != exp) printf("."); &#125; //如果exp足够大，输出普通数字不含小数，添exp-(pos-3)个零 for (i = 0; i &lt; exp - (pos - 3); i++) printf("0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1020 Tree Traversals (25 point(s))]]></title>
    <url>%2F2019%2F08%2F02%2FPAT%20A1020%20Tree%20Traversals%20(25%20point(s))%2F</url>
    <content type="text"><![CDATA[Problem DescriptionSuppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input SpecificationEach input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output SpecificationFor each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input72 3 1 5 7 6 41 2 3 4 5 6 7 Sample Output4 1 6 3 5 7 2 题目大意假设二叉树的所有键都是不同的正整数，并给出后序遍历和中序遍历，要求输出相应二叉树的层序遍历。 思路二叉树的遍历问题 输入案例分析在输入样例中，第一行给的是二叉树总共的节点数，第二行给出的是前序遍历序列，第三行给出的是终须遍历序列。 具体操作通过输入案例第一行给出的数字，确定遍历序列的元素总数。在前序遍历序列中，序列最后一个元素便是二叉树的根节点，所以，我们可以拿根节点，在中序遍历序列中，进行元素的比较，从而，确定在中序遍历序列中根节点的位置。由中序遍历的性质知，中序遍历序列根节点左侧的元素便是左子树中的元素，根节点右侧的元素便是右子树中的元素。进行递归调用后，便可得到这棵的二叉树。最后，对二叉树进行层序遍历即可。应注意的是，输出的最后一个节点的数据后是没有空格的。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# include&lt;cstdio&gt;# include&lt;cstring&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;int n;//接受第一行输入的节点数int post[50], in[50];//接受二三行输入的后序与中序遍历序列struct node&#123; int data; node* lchild; node* rchild;&#125;;//建树，返回为建好树的根节点node* create(int postL, int postR, int inL, int inR) &#123; if (postL &gt; postR) &#123; return NULL;//如果后序序列的长度小于1，直接返回 &#125; node* root = new node;//新建节点，存储当前根节点 root-&gt;data = post[postR];//根节点数据域为根节点的值 int k;//k用来存储，根节点在中序遍历中的位置 for (k = inL; k &lt;= inR; k++) &#123; if (in[k] == post[postR]) &#123;//找到中序遍历序列中根节点 break; &#125; &#125; int numLChild = k - inL;//左子树节点个数 //递归调用，左(右)子树根节点地址给左(右)指针 root-&gt;lchild = create(postL, postL + numLChild - 1, inL, k - 1); root-&gt;rchild = create(postL + numLChild, postR - 1, k + 1, inR); return root;&#125;//输出层序遍历int num = 0;//已输出节点数void LayerOrder(node* root) &#123; queue&lt;node*&gt; q; q.push(root);//根节点入队 while (!q.empty()) &#123;// node* now = q.front(); q.pop(); printf("%d", now-&gt;data);//输出队首元素的值 num++; if (num &lt; n) &#123; printf(" ");//节点数据后有空格，而最后一个节点的输没有每空格。 &#125; if (now-&gt;lchild != NULL) q.push(now-&gt;lchild); if (now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node* root = create(0, n - 1, 0, n - 1);//建树 LayerOrder(root);//层序遍历 return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1014 福尔摩斯的约会 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F02%2FPAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A-20-point-s%2F</url>
    <content type="text"><![CDATA[题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 输出样例：THU 14:04 题意：给出四个字符串，前两个字符串内含有约会的星期，与约会的钟头;后两个字符串内含有约会的具体分钟。要求通过如下规则处理四个字符串，得到约会的具体时间， 星期：比较前两个字符串，确定同一位置第一对相同的大写字母，A~G分别代表星期一至星期日；钟头：比较前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），0到9分别代表0点到9点、大写字母 A 到 N分别代表10点到23点；分钟：比较后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。 最后按DAY HH:MM格式输出。 思路：字符串处理问题，通过三次循环处理，分别得到星期，钟头，分钟。 第一步：扫描前两个字符串，确定同一位置第一对相同的大写字母（A~G），与字符A的距离是多少，便是星期几。 第二步：在第一步的基础上，继续扫描前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），将其转换为0~23。 第三步：扫描后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;int main() &#123; char week[7][4] = &#123;"MON","TUE","WED","THU","FRI","SAT","SUN"&#125;; //接收输入4条字符串 char str1[65]; char str2[65]; char str3[65]; char str4[65]; fgets(str1, 65, stdin); fgets(str2, 65, stdin); fgets(str3, 65, stdin); fgets(str4, 65, stdin); //得到字符串长度，为通过循环比较相同字符，做准备 int len1 = strlen(str1); int len2 = strlen(str2); int len3 = strlen(str3); int len4 = strlen(str4); int i = 0; //寻找前两字符串第一对相同的大写字母，确定星期 for (i = 0; i &lt; len1&amp;&amp;i &lt; len2; i++) &#123; if (str1[i] == str2[i] &amp;&amp; str1[i] &gt;= 'A'&amp;&amp;str1[i] &lt;= 'G') &#123;//保证同位置字符相同，且全为大写字母 printf("%s ", week[str1[i] - 'A']); break; &#125; &#125; //在上次循环的基础上，继续循环查找相同的字符，确定小时 for (i++; i &lt; len1&amp;&amp;i &lt; len2; i++) &#123; if (str1[i] == str2[i]) &#123;//分别讨论当字符为数字，和大写字母两种情况 if (str1[i] &gt;= '0'&amp;&amp;str1[i] &lt;= '9') &#123; printf("%02d:", str1[i] - '0'); break; &#125; else if (str1[i] &gt;= 'A'&amp;&amp;str1[i] &lt;= 'N') &#123; printf("%02d:", str1[i] - 'A' + 10); break; &#125; &#125; &#125; //确定后两字符串，第一对相同字符出现的位置 for (i = 0; i &lt; len3&amp;&amp;i &lt; len4; i++) &#123; if (str3[i] == str4[i]) &#123; if ((str3[i] &gt;= 'A'&amp;&amp;str3[i] &lt;= 'Z') || (str3[i] &gt;= 'a'&amp;&amp;str3[i] &lt;= 'z')) &#123; printf("%02d", i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo框架的博客，Markdown文章无法插入图片问题的解决]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%85%B3%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8Cmarkdown%E6%96%87%E7%AB%A0%E6%97%A0%E6%B3%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言：在使用Markdown编辑博客文章时，在markdown文件中可以看到插入的图片，但是，在Next主题以及很多其他主题下，博客页面均无法显示图片。在查询了很多资料无果后，发现是简单的存储路径的问题。 使用Markdown将图片插入文章Markdown支持图片的后缀名为.jpg,.png, .gif,通过Markdown语法![图片描述]（图片路径）即可插入图片。如，我将一个图片保存到D:\Blog\luHeXin\source\images\文件路径\1.jdg路径，此篇Markdown文章保存在D:\Blog\luHeXin\source\_posts路径，则只需要使用语法![图片](/source/images/文件路径/1.jpg)便可在本地中看到图片，但是部署到githubPages时却出现如下效果。.只有将上述路径修改为![图片]![](https://luhexin.github.io/images/文件路径/1.jpg)并重新部署到服务器上时，才能正常显示图片，效果如下. 相对路径的表示方法在解决此问题前，我们应了解一下相对路径的几种表示方法， ./ ：代表文件所在的目录（可以省略不写） ../ ：代表文件所在的父级目录 ../../ ：代表文件所在的父级目录的父级目录 / ：代表文件所在的根目录 产生问题的原因上述例子中第一种路径的写法/source/images/文件路径/1.jpg便是告诉计算机去文件所在的根目录(D:\Blog\luHeXin\)中寻找图片,寻找的路径为 d:\Blog\luHeXin\images\文件路径\1.jpg 这正是图片所在的路径，所以在markdown文件中查看是没有问题的。 但是部署到服务器上时，所显示页面的index.html文件，是由hexo博客框架静态生成的，而该文件的位置与Markdown所编辑的文章并在一个文件夹里。所以，使用相对路径的写法，即使在markdown文件中可以看到图片，但，在所生成的静态文件中，也会因为index.html文件所在目录的不同，而导致寻找图片路径不同。 问题的最终解决我发现部署在服务器上图片的绝对路径是https://luhexin.github.io/images/文件路径/1.jpg,（此图片在工作区文件夹中的位置为D:\Blog\luHeXin\source\images\文件路径\1.jpg）因此，我们一律采用绝对路径的方式添加图片![](https://luhexin.github.io/images/文件路径/1.jpg)。 参考文章https://baijiahao.baidu.com/s?id=1606046350230601762&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>文件路径问题</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探git和github]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%88%9D%E6%8E%A2git%E5%92%8Cgithub%2F</url>
    <content type="text"><![CDATA[简介该篇文章将简单的介绍如何通过git来上传自己的代码至github，如何进行分支开发，以及如何克隆github中的代码到本地。 第一步下载git注册github账号 第二步 （在github中建立仓库）登录github，点击右上方头像，展开如下菜单，并点击Your profile，进入个人主页。 选择并点击上方的Respositories便可进入仓库,点击右侧绿色的按钮new进行新建仓库. 添加必要信息之后点击Create Respositories之后便可便成功创建了一个仓库。 如上图，仓库创建成功。 第三步（创建SSH）点击右上角头像，展开目录后，点击setting进入设置页面。 点击左侧SSH and GPG keys,再点击new ssh key。 这时他需要填Title和key Title一栏可以随意填写，而key一栏我们则需要手动获取。 回到桌面，鼠标右键，选择git bash here，打开git命令栏窗口。输入ssh-keygen点击回车,便会出现如下路径（路径汇银因客户端的不同而不同）。 按此路径找到id_rsa.pub文件，打开方式选择以记事本方式打开，这里的内容便是key栏中需要填写的内容，复制以下内容，粘贴到key一栏即可。 重新回到仓库界面，点击clone or down，使用ssh，并复制一下这个链接 第四步 （复制代码至本地）在任意位置创建一个空文件夹（文件夹名字随意），打开文件夹后，鼠标右键,选择git bash here，打开git命令栏窗口。输入指令git clone + 粘贴刚才复制的那一段链接，并回车，如下图所示 回到文件夹中，便看到原本空文件夹里多出了一个文件夹，此文件夹便是github中的文件。 第五步（1） （将代码推到github）这是git推送文件的流程 工作区：便是本地电脑中可以看到的目录 暂存区：一般存放在 “.git目录下” 下的index文件（.git/index）中 版本库：工作区的一个隐藏目录.git（是Git的版本库）。 我们打开上一步中克隆的文件夹，新建一个文件1.txt 鼠标右键,选择git bash here输入指令git add . 并回车，将文件添加到版本区。(这里的 .代表该目录下所有文件至版本区也可以单独添加1.txt文件git add 1.txt) 继续输入指令git commit -m &quot;update&quot;（双引号里的内容是提交到github中的文件描述，所以双引号里的内容任意） 最后输入指令git push将文件推到远端。回到仓库刷新后，便可看到提交的文件 第五步（2） （将代码推到github）（若读者是已经进行了第四步与第五步（2）可以先不进行本步骤操作）上一步是在复制代码至本地的基础上进行的，若没进行第四步的操作，直接将代码推到github上则需 新建需推到远端的文件如1.txt. 在文件夹中打开git命令窗口，输入git init进行初始化，此时系统会自动创建.git隐藏文件。 回到github仓库，先复制https链接，接着在命令窗口输入git remote add origin 复制好的链接 git pull origin master ，进行刷新 接着我们就可以进行提交操作 git add . git commi -m &quot;dev&quot; 由于这是初始化后的第一次推到远端，所以我们指出推到的分支，即输入如下命令，将文件推到master分支上 git push origin master 删除提交的文件可以直接在github上进行可视化的编辑，点击要删除的文件名，进入该文件在github中的文件属性页，进行如下图操作。 分支开发 依旧在文件夹中打开git命令行窗口。由于我们在远端github上执行了删除命令的操作，导致远端的文件与本地文件不同，这时便需要在命令行窗口输入指令git pull 并回车，进行刷新操作。（有时在不确定远端是否更改时也可以通过git pull指令来进行刷新） 刷新之后，通过指令git branch dev并回车，创建分支（dev是创建的分支名，在这里也可以随意命名分支）。 git checkout dev并回车,便切换到了dev分支。 在文件夹中创建文件dev.txt 提交分支文件，git add . git commi -m &quot;dev&quot;git push 此时由于是第一次在该分支提交文件，git push指令并没有是文件提交到远端，此时根据提示输入git push --set-upstream origin dev回车后，待push完毕后便可看到仓库中多了一个分支，分支中的文件便是刚提交的文件。（只有dev分支有dev.txt文件） 后续提交 返回文件夹新建dev2.txt文件提交分支文件，git add . git commi -m &quot;dev&quot;git push 此时发现不需输入指令git push --set-upstream origin dev便可提交到github中，其实，只有在切换分支后以及git的初始化后的第一次提交会提示需要在添加此指令，在以后的push过程中并不需要添加此指令。在github中查看，dev2.txt已上传完毕 合并dev分支至master git checkout master切换到主分支git pull刷新git merge dev合并请求git push推到github上回到仓库，切换到master分支，这时发现master分支多出了dev.txt和dev2.txt两个原本在dev分支上的文件。此时便说明分支合并成功了。值得注意的是，我们如今已切换到了master分支。若想将文件提交到刚刚的dev分支上则需先通过指令git checkout dev切换会dev分支，再进行陆续操作。 参考文章https://www.runoob.com/git/git-workspace-index-repo.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化_更改选中字符及超链接颜色]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8D%9A%E5%AE%A2%E9%80%89%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%B6%85%E9%93%BE%E6%8E%A5%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[前言NesT主题默认的选中字符颜色以及超链接颜色和周围网页、文字颜色相近不易区分。因此，选择手动更改二者颜色。 修改步骤第一步打开主题配置文件_config.yml查看自己选择的主题方案。在这里我选择的是scheme: Gemini，因此，接下来我也将以该方案为例。 第二步打开\themes\next\source\css\_schemes\Gemini\index.styl若已选择其他主题，则只需按路径打开_schemes文件夹下对应的方案，在选择打开对应的index.styl文件即可。 第三步修改选中字符的颜色在上一步打开的文件末尾添加如下代码 12345// 修改选中字符的颜色::selection &#123; background: #3366ff; color: #FFFFFF; &#125; 选中字符后字符的颜色变为白色，选中的背景为蓝色。当然，也可以根据RGB颜色对照表在这里随意改成自己喜欢颜色。 第四步修改代码块选中的颜色打开，如下路径\themes\next\source\css\_common\components\highlight\highlight.style找到 123*::selection &#123; background: $highlight-selection; &#125; 修改为 1234//修改代码块颜色*::selection &#123; background: #3366ff; &#125; 这里更改代码块选中背景色为蓝色。 第五步修改超链接颜色打开\themes\next\source\css\_schemes\Gemini\index.styl在文件末尾添加如下代码 1234567891011// 文章内链接文本样式 .post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125; 参考文章https://www.jianshu.com/p/2a8d399f1266]]></content>
      <categories>
        <category>博客美化</category>
      </categories>
      <tags>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化_点击特效的实现]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8D%9A%E5%AE%A2%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[简介本博客基于Hexo博客框架，主题选择的是NexT( NexT使用文档)。通过使用jQuery，为博客添加点击特效。 思路 通过jQuery click()函数，获取html标签中点击的事件，并调用相应方法 12$("html").click(function(e) &#123;&#125; 内置一个数组用来存储点击时出现的内容，通过jQuery设置返回的元素内容 123var a = new Array("奋斗!!!","努力!!!","Learning~","Coding~","Summarizing~","Advancing~","VENI","VIDI","VICI","٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ");var i = $("&lt;span&gt;&lt;/span&gt;").text(a[a_index]);a_index = (a_index + 1) % a.length; 在这里jQuery返回的数组内容顺序是按照数组a[0]有序读到最后的。若将 1a_index = (a_index + 1) % a.length; 替换为 1a_index = Math.round(Math.random()*a.length); 则将随机返回数组内的内容。 获取点击时鼠标的位置，将横纵坐标分别存储在变量x、y中。并在css中添加字体特效颜色，以及出现字体的位置。 123456789var x = e.pageX,y = e.pageY;i.css(&#123; "z-index": 66666666666666666666666666666666666666666666666666666666666, "top": y -10, "left": x, "position": "absolute", "font-weight": "bold", "color": "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" &#125;); 这里为保证特效不被遮挡一次设置一个较大的z-index。字体出现的初始位置为鼠标点击位置正上方10单位的位置上. 将字体添加到html中 1$("html").append(i); 通过jQuery animate()方法制作点击特效 12345678i.animate(&#123; "top": y-180 , "opacity": 0 &#125;, 1500, function() &#123; i.remove(); &#125;); 在这里设置动画的效果为特效字体从鼠标点击位置开始逐渐向上180个单位，上升的过程中逐渐淡化，在1.5秒后消失。 完整代码12345678910111213141516171819202122232425262728var a_index = 0;jQuery(document).ready(function($) &#123; $("html").click(function(e) &#123; var a = new Array("奋斗!!!","努力!!!","Learning~","Coding~","Summarizing~","Advancing~","VENI","VIDI","VICI","٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ"); var i = $("&lt;span&gt;&lt;/span&gt;").text(a[a_index]); a_index = (a_index + 1) % a.length; // a_index = Math.round(Math.random()*a.length);//随机出现点击内容 var x = e.pageX, y = e.pageY; i.css(&#123; "z-index": 66666666666666666666666666666666666666666666666666666666666, "top": y -10, "left": x, "position": "absolute", "font-weight": "bold", "color": "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" &#125;); $("html").append(i); i.animate(&#123; "top": y - 180 , "opacity": 0 &#125;, 1500, function() &#123; i.remove(); &#125;); &#125;);&#125;); 相关配置由于此博客选择的主题是NexT，因此有关的配置我也以NexT为例。 将上述js代码命名为special-effect.js，并移动到如下目录：\themes\next\source\js 在如下路径：\themes\next\layout\layout.swig找到倒数第二行的标签的前面添加如下代码 123&#123;% if theme.special-effect %&#125;&lt;script type="text/javascript" src="/js/special-effect.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在主题配置文件（\themes\next_congig.yml）末尾加入： 12#special-effectspecial-effect: true]]></content>
      <categories>
        <category>博客美化</category>
      </categories>
      <tags>
        <tag>点击特效</tag>
        <tag>JS</tag>
        <tag>博客美化</tag>
      </tags>
  </entry>
</search>
