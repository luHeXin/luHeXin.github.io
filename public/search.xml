<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot注解详解]]></title>
    <url>%2F2019%2F08%2F08%2FSpringBoot%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解的含义 Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。 这是比较官方的说法。于我而言，我更倾向于把注解理解成代码的标签,其作用就是对对象进行某些角度解释。 注解对于Springboot的重要性注解是springboot的核心内容，在springboot中，通过各种组合注解，极大地简化了spring项目的搭建和开发。因此，我们需要知道主键的基本概念以及使用方法，才能够更加理解Springboot框架。 注解分类1.按照声明周期 源码注解（仅在.java文件中存在，经过编译就不存在了） 编译时注解（在编译时起作用，即在.class文件中也仍然存在） 运行时注解（在运行阶段起作用，有时会影响程序的运行逻辑） 2.按照来源 JDK自带的注解 第三方框架注解 自定义注解 3.元注解 对注解进行注解的注解 注解列表 @Autowired自动导入依赖的bean。 @Bean：产生一个bean,并交给spring管理。相当于XML中配置的bean。 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。可配合CommandLineRunner使用，在程序启动后执行一些基础任务。 @ComponentScan组件扫描，可自动发现和装配一些Bean。 @Configuration等同于spring的XML配置文件；使用Java代码可以检查类型安全。 @Controller：用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。 @EnableAutoConfiguration自动配置。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。 @Import：用来导入其他配置类。 @ImportResource：用来加载xml配置文件。 @Inject：等价于默认的@Autowired，只是没有required属性； @JsonBackReference解决嵌套外链问题。 @PathVariable获取参数。 @Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者， @Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。 @RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。 @RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射。 @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。 @Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。 @RestController是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。 @Service：一般用于修饰service层的组件 @SpringBootApplication包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。 @Value：注入Spring boot application.properties配置的属性的值。 核心注解详解：@SpringBootApplication申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。示例代码： 12345678910package com.example.myproject; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; @ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。示例代码： 12345@RequestMapping(“/test”) @ResponseBody public String test()&#123; return "index"; &#125; @Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。示例代码： 12345678910@Controller@RequestMapping("/hello")public class HelloController &#123; @GetMapping("/say/&#123;id&#125;") public String say()&#123; //返回index.html return "index"; &#125;&#125; @RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。示例代码： 1234567891011@RestController@RequestMapping("/hello")public class HelloController &#123; @GetMapping("/say/&#123;id&#125;") public String say(@RequestParam(value = "id",required = false,defaultValue = "0") Integer id)&#123; return "id:"+id; &#125;&#125; JPA注解需先在Maven中引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; @Column：如果字段名与列名相同，则可以省略。 @Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略 @GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。 @Id：表示该属性为主键。 @JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。 @JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。 @MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。 @NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。 @OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。 @SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。 @Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式 springMVC相关注解 @PathVariable:路径变量，示例代码1234RequestMapping(“user/get/mac/&#123;macAddress&#125;”) public String getByMacAddress(@PathVariable String macAddress)&#123; //do something; &#125; 参数与大括号里的名字一样要相同。 @RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：params:指定request中必须包含某些参数值是，才让该方法处理。headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。value:指定请求的实际地址，指定的地址可以是URI Template 模式method:指定请求的method类型， GET、POST、PUT、DELETE等consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 @RequestParam：用在方法的参数前面。示例代码： 12@RequestParam String a =request.getParameter(“a”)。 全局异常处理: @ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。 @ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。 参考文章：(Spring Boot 注解—基本知识)[https://www.jianshu.com/p/d74ed7374841](SpringBoot注解最全详解(整合超详细版本))[https://blog.csdn.net/weixin_40753536/article/details/81285046]([springBoot系列]–springBoot注解大全)[https://www.cnblogs.com/tanwei81/p/6814022.html]]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Springboot注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1048 数字加密 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F06%2FB1048%2F</url>
    <content type="text"><![CDATA[题目描述：本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入案例：1234567 368782971 输出案例：3695Q8118 题目分析：简单的字符串处理问题。对于输入案例，字符串读入的时候是a[0]=’1’,a[1]=’2’….,但是，1234567的个位数字是7，题目要求令个位为第一位。因此，需要反转两次字符串，第一次是在，进行奇偶位数操作时；第二次，是在输出的时，转化字符串，使个位在字符串最右侧。 思路： 比较两字符串长度，选择较长的长度，作为循环上限。 分情况处理，奇偶位不同操作（这里的奇偶位与数组脚标的奇偶是相反的）。 注意两次字符串的反转。 参考代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 110;char a[maxn], b[maxn], ans[maxn];void reverse(char s[]) &#123;//反转字符 int len = strlen(s); char temp; for (int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125;int main() &#123; scanf("%s %s", a, b); reverse(a); reverse(b); int lenA = strlen(a); int lenB = strlen(b); int len = lenA &gt; lenB ? lenA : lenB; for (int i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? a[i] - '0' : 0;//字符转化为整数，超过长度，零来补位 int numB = i &lt; lenB ? b[i] - '0' : 0; if (i % 2 == 0) &#123;//i为偶数，奇数位 int temp = (numA + numB) % 13; if (temp == 10)ans[i] = 'J'; else if (temp == 11)ans[i] = 'Q'; else if (temp == 12)ans[i] = 'K'; else ans[i] = temp + '0';//转换为字符 &#125; else &#123; int temp = numB - numA; if (temp &lt; 0) temp += 10; ans[i] = temp + '0';//转换为字符 &#125; &#125; reverse(ans);//反转字符串 puts(ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过Spring-Data-Jpa连接MySQL,并操作数据库]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%80%9A%E8%BF%87Spring-Data-Jpa%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[版本MySQL：5.7.27 jdk：12.0.1 Navicat：12.0.20 IDEA：2018.2.4 具体操作1. 引入依赖spring-boot-starter-data-jpa与mysql-connector-java 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; Springboot自动帮我们选择了版本。所以，在这个位置，不必手动选择版本。 2. 新建数据库命名为test，具体格式如下图所示。（Character set与Collation的选择是为了后续项目进行所需，读者可根据所需自行选择。当然，对于仅连接连接MySQL而言，就算全为默认也是可以的。） 3. 写配置 12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: create show-sql: true 要注意url中，要添加时域serverTimezone=UTC，否则，可能报错Unable to create requested service [org.hibernate.engine.jdbc.env.spi.JdbcEnvironment] 4. 建表表中含有id，money，producer，consumer四个字段新建一个类 test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.lu.test;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import java.math.BigDecimal;@Entitypublic class test &#123; @Id @GeneratedValue private Integer id; private BigDecimal money; private String producer; private String consumer; public test() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public BigDecimal getMoney() &#123; return money; &#125; public void setMoney(BigDecimal money) &#123; this.money = money; &#125; public String getProducer() &#123; return producer; &#125; public void setProducer(String producer) &#123; this.producer = producer; &#125; public String getConsumer() &#123; return consumer; &#125; public void setConsumer(String consumer) &#123; this.consumer = consumer; &#125;&#125; 运行之后，出现如下信息： Hibernate: drop table if exists hibernate_sequence Hibernate: drop table if exists luckymoney Hibernate: create table hibernate_sequence (next_val bigint) engine=MyISAM Hibernate: insert into hibernate_sequence values ( 1 ) Hibernate: create table luckymoney (id integer not null, consumer varchar(255), money decimal(19,2), producer varchar(255), primary key (id)) engine=MyISAM返回到。数据库便可以看到，已经建好了一个名为test的表。 5. 更新表中的内容在数据库中，向新建的表输入内容并保存之后，返回IDEA再次运行代码，则，springboot会重新建一个名为test表，并覆盖旧表，清空旧表数据。 因此，在建好表后，需要更新数据，则应先返回到配置文件中，将 ddl-auto: create更改为ddl-auto: update，这样，在下一次运行IDEA时，才会保留数据库表中的信息。]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1024 科学计数法 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F03%2FB1024%2F</url>
    <content type="text"><![CDATA[题目描述：科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 输入格式：每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 输出格式：对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 输入样例 1：+1.23400E-03 输出样例 1：0.00123400 输入样例 2：-1.2E+10 输出样例 2：-12000000000 题目分析：给定一组用科学计数法表示的数字，要求将其转化为正常表示数字，并输出. 思路： 先输出字符串正负，正号不输出，符号正常输出。 扫描字符串，找到E，E相当于分隔符，左侧为小数部分，右侧为指数部分。 指数小于零，小数点往左移，输出0.000…xxxx。 指数大于零，小数点往右移，有两种情况。 第一种情况：小数点移完，数字还是小数x…xx . x..xx。 第二种情况：小数点移完，数字变为整数xxxxx…xxxx或者xxxx…xxx00000。 指数为零，直接输出小数部分。 注意点 使用fgets()接受输入，是其字符串长度是strlen(s)-1。 注意数字存储长度，题目中说数字存储长度不超过9999Byte，而一个字符是1Byte，所以不超过9999字符。 要考虑指数为零的情况。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;int const maxn = 10010;//一个char类型的为一个字节，长度不超过9999个字符，因此选择10010int main() &#123; int i = 0; char s[maxn]; fgets(s, maxn, stdin); int pos = 0;//记录E的位置，E后为指数，前为普通数字 while (s[i]!='E') &#123; i++; &#125; pos = i; //输出正负号 if (s[0] == '+') printf(""); else if (s[0] == '-')printf("-"); int len = strlen(s)-1; int exp = 0;//exp中存储指数 for (i = pos + 2; i &lt; len; i++) &#123;//因为E的位置为pos而E后的一个为正负号，所以第一个数字式pos+2 exp = exp * 10 + (s[i] - '0'); &#125; //如果指数是零，直接输出 if (exp == 0) &#123; for (i = 1; i &lt; pos; i++) &#123; printf("%c", s[i]); &#125; &#125; //指数小于零先输出0，再输出exp-1个零。再输出数字，但是数字不能有小数点 if (s[pos+1] =='-') &#123; printf("0."); for (i = 0; i &lt; exp - 1; i++) &#123; printf("0"); &#125; printf("%c", s[1]); for (i = 3; i &lt; pos; i++) &#123; //if (s[i] == '.') continue;//遇到小数点则跳过 printf("%c", s[i]); &#125; &#125; //输出指数大于零 else &#123; for (i = 1; i &lt; pos; i++) &#123; if (s[i] == '.') continue; printf("%c", s[i]);//输出数字 //添加小数点,加在exp+2位置 //科学计数法中，小数位数为pos-3，小数点移动的位数(exp)等于小数位数不加小数点 if (i == exp + 2 &amp;&amp; pos - 3 != exp) printf("."); &#125; //如果exp足够大，输出普通数字不含小数，添exp-(pos-3)个零 for (i = 0; i &lt; exp - (pos - 3); i++) printf("0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT A1020 Tree Traversals (25 point(s))]]></title>
    <url>%2F2019%2F08%2F02%2FPAT%20A1020%20Tree%20Traversals%20(25%20point(s))%2F</url>
    <content type="text"><![CDATA[Problem DescriptionSuppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input:72 3 1 5 7 6 41 2 3 4 5 6 7 Sample Output:4 1 6 3 5 7 2 题目大意：假设二叉树的所有键都是不同的正整数，并给出后序遍历和中序遍历，要求输出相应二叉树的层序遍历。 思路：二叉树的遍历问题 输入案例分析：在输入样例中，第一行给的是二叉树总共的节点数，第二行给出的是前序遍历序列，第三行给出的是终须遍历序列。 具体操作：通过输入案例第一行给出的数字，确定遍历序列的元素总数。在前序遍历序列中，序列最后一个元素便是二叉树的根节点，所以，我们可以拿根节点，在中序遍历序列中，进行元素的比较，从而，确定在中序遍历序列中根节点的位置。由中序遍历的性质知，中序遍历序列根节点左侧的元素便是左子树中的元素，根节点右侧的元素便是右子树中的元素。进行递归调用后，便可得到这棵的二叉树。最后，对二叉树进行层序遍历即可。应注意的是，输出的最后一个节点的数据后是没有空格的。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# include&lt;cstdio&gt;# include&lt;cstring&gt;# include&lt;algorithm&gt;# include&lt;queue&gt;using namespace std;int n;//接受第一行输入的节点数int post[50], in[50];//接受二三行输入的后序与中序遍历序列struct node&#123; int data; node* lchild; node* rchild;&#125;;//建树，返回为建好树的根节点node* create(int postL, int postR, int inL, int inR) &#123; if (postL &gt; postR) &#123; return NULL;//如果后序序列的长度小于1，直接返回 &#125; node* root = new node;//新建节点，存储当前根节点 root-&gt;data = post[postR];//根节点数据域为根节点的值 int k;//k用来存储，根节点在中序遍历中的位置 for (k = inL; k &lt;= inR; k++) &#123; if (in[k] == post[postR]) &#123;//找到中序遍历序列中根节点 break; &#125; &#125; int numLChild = k - inL;//左子树节点个数 //递归调用，左(右)子树根节点地址给左(右)指针 root-&gt;lchild = create(postL, postL + numLChild - 1, inL, k - 1); root-&gt;rchild = create(postL + numLChild, postR - 1, k + 1, inR); return root;&#125;//输出层序遍历int num = 0;//已输出节点数void LayerOrder(node* root) &#123; queue&lt;node*&gt; q; q.push(root);//根节点入队 while (!q.empty()) &#123;// node* now = q.front(); q.pop(); printf("%d", now-&gt;data);//输出队首元素的值 num++; if (num &lt; n) &#123; printf(" ");//节点数据后有空格，而最后一个节点的输没有每空格。 &#125; if (now-&gt;lchild != NULL) q.push(now-&gt;lchild); if (now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node* root = create(0, n - 1, 0, n - 1);//建树 LayerOrder(root);//层序遍历 return 0;&#125;]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B1014 福尔摩斯的约会 (20 point(s))]]></title>
    <url>%2F2019%2F08%2F02%2FPAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A-20-point-s%2F</url>
    <content type="text"><![CDATA[题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 输出样例：THU 14:04 题意：给出四个字符串，前两个字符串内含有约会的星期，与约会的钟头;后两个字符串内含有约会的具体分钟。要求通过如下规则处理四个字符串，得到约会的具体时间， 星期：比较前两个字符串，确定同一位置第一对相同的大写字母，A~G分别代表星期一至星期日；钟头：比较前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），0到9分别代表0点到9点、大写字母 A 到 N分别代表10点到23点；分钟：比较后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。 最后按DAY HH:MM格式输出。 思路：字符串处理问题，通过三次循环处理，分别得到星期，钟头，分钟。 第一步：扫描前两个字符串，确定同一位置第一对相同的大写字母（A~G），与字符A的距离是多少，便是星期几。 第二步：在第一步的基础上，继续扫描前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），将其转换为0~23。 第三步：扫描后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。 参考代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;int main() &#123; char week[7][4] = &#123;"MON","TUE","WED","THU","FRI","SAT","SUN"&#125;; //接收输入4条字符串 char str1[65]; char str2[65]; char str3[65]; char str4[65]; fgets(str1, 65, stdin); fgets(str2, 65, stdin); fgets(str3, 65, stdin); fgets(str4, 65, stdin); //得到字符串长度，为通过循环比较相同字符，做准备 int len1 = strlen(str1); int len2 = strlen(str2); int len3 = strlen(str3); int len4 = strlen(str4); int i = 0; //寻找前两字符串第一对相同的大写字母，确定星期 for (i = 0; i &lt; len1&amp;&amp;i &lt; len2; i++) &#123; if (str1[i] == str2[i] &amp;&amp; str1[i] &gt;= 'A'&amp;&amp;str1[i] &lt;= 'G') &#123;//保证同位置字符相同，且全为大写字母 printf("%s ", week[str1[i] - 'A']); break; &#125; &#125; //在上次循环的基础上，继续循环查找相同的字符，确定小时 for (i++; i &lt; len1&amp;&amp;i &lt; len2; i++) &#123; if (str1[i] == str2[i]) &#123;//分别讨论当字符为数字，和大写字母两种情况 if (str1[i] &gt;= '0'&amp;&amp;str1[i] &lt;= '9') &#123; printf("%02d:", str1[i] - '0'); break; &#125; else if (str1[i] &gt;= 'A'&amp;&amp;str1[i] &lt;= 'N') &#123; printf("%02d:", str1[i] - 'A' + 10); break; &#125; &#125; &#125; //确定后两字符串，第一对相同字符出现的位置 for (i = 0; i &lt; len3&amp;&amp;i &lt; len4; i++) &#123; if (str3[i] == str4[i]) &#123; if ((str3[i] &gt;= 'A'&amp;&amp;str3[i] &lt;= 'Z') || (str3[i] &gt;= 'a'&amp;&amp;str3[i] &lt;= 'z')) &#123; printf("%02d", i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo框架的博客，Markdown文章无法插入图片问题的解决]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%85%B3%E4%BA%8Ehexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8Cmarkdown%E6%96%87%E7%AB%A0%E6%97%A0%E6%B3%95%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[前言：在使用Markdown编辑博客文章时，在markdown文件中可以看到插入的图片，但是，在Next主题以及很多其他主题下，博客页面均无法显示图片。在查询了很多资料无果后，发现是简单的存储路径的问题。 使用Markdown将图片插入文章Markdown支持图片的后缀名为.jpg,.png, .gif,通过Markdown语法![图片描述]（图片路径）即可插入图片。如，我将一个图片保存到D:\Blog\luHeXin\source\images\文件路径\1.jdg路径，此篇Markdown文章保存在D:\Blog\luHeXin\source\_posts路径，则只需要使用语法![图片](/source/images/文件路径/1.jpg)便可在本地中看到图片，但是部署到githubPages时却出现如下效果。.只有将上述路径修改为![图片]![](https://luhexin.github.io/images/文件路径/1.jpg)并重新部署到服务器上时，才能正常显示图片，效果如下. 相对路径的表示方法在解决此问题前，我们应了解一下相对路径的几种表示方法， ./ ：代表文件所在的目录（可以省略不写） ../ ：代表文件所在的父级目录 ../../ ：代表文件所在的父级目录的父级目录 / ：代表文件所在的根目录 产生问题的原因上述例子中第一种路径的写法/source/images/文件路径/1.jpg便是告诉计算机去文件所在的根目录(D:\Blog\luHeXin\)中寻找图片,寻找的路径为 d:\Blog\luHeXin\images\文件路径\1.jpg 这正是图片所在的路径，所以在markdown文件中查看是没有问题的。 但是部署到服务器上时，所显示页面的index.html文件，是由hexo博客框架静态生成的，而该文件的位置与Markdown所编辑的文章并在一个文件夹里。所以，使用相对路径的写法，即使在markdown文件中可以看到图片，但，在所生成的静态文件中，也会因为index.html文件所在目录的不同，而导致寻找图片路径不同。 问题的最终解决我发现部署在服务器上图片的绝对路径是https://luhexin.github.io/images/文件路径/1.jpg,（此图片在工作区文件夹中的位置为D:\Blog\luHeXin\source\images\文件路径\1.jpg）因此，我们一律采用绝对路径的方式添加图片![](https://luhexin.github.io/images/文件路径/1.jpg)。 参考文章https://baijiahao.baidu.com/s?id=1606046350230601762&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>文件路径问题</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探git和github]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%88%9D%E6%8E%A2git%E5%92%8Cgithub%2F</url>
    <content type="text"><![CDATA[简介此篇文章内容浅显，针对于未接触过git的小白。该篇文章将简单的介绍如何通过git来上传自己的代码至github，如何进行分支开发，以及如何克隆github中的代码到本地。 第一步下载git注册github账号 第二步 （在github中建立仓库）登录github，点击右上方头像，展开如下菜单，并点击Your profile，进入个人主页。 选择并点击上方的Respositories便可进入仓库,点击右侧绿色的按钮new进行新建仓库. 添加必要信息之后点击Create Respositories之后便可便成功创建了一个仓库。 如上图，仓库创建成功。 第三步（创建SSH）点击右上角头像，展开目录后，点击setting进入设置页面。 点击左侧SSH and GPG keys,再点击new ssh key。 这时他需要填Title和key Title一栏可以随意填写，而key一栏我们则需要手动获取。 回到桌面，鼠标右键，选择git bash here，打开git命令栏窗口。输入ssh-keygen点击回车,便会出现如下路径（路径汇银因客户端的不同而不同）。 按此路径找到id_rsa.pub文件，打开方式选择以记事本方式打开，这里的内容便是key栏中需要填写的内容，复制以下内容，粘贴到key一栏即可。 重新回到仓库界面，点击clone or down，使用ssh，并复制一下这个链接 第四步 （复制代码至本地）在任意位置创建一个空文件夹（文件夹名字随意），打开文件夹后，鼠标右键,选择git bash here，打开git命令栏窗口。输入指令git clone + 粘贴刚才复制的那一段链接，并回车，如下图所示 回到文件夹中，便看到原本空文件夹里多出了一个文件夹，此文件夹便是github中的文件。 第五步（1） （将代码推到github）这是git推送文件的流程 工作区：便是本地电脑中可以看到的目录 暂存区：一般存放在 “.git目录下” 下的index文件（.git/index）中 版本库：工作区的一个隐藏目录.git（是Git的版本库）。 我们打开上一步中克隆的文件夹，新建一个文件1.txt 鼠标右键,选择git bash here输入指令git add . 并回车，将文件添加到版本区。(这里的 .代表该目录下所有文件至版本区也可以单独添加1.txt文件git add 1.txt) 继续输入指令git commit -m &quot;update&quot;（双引号里的内容是提交到github中的文件描述，所以双引号里的内容任意） 最后输入指令git push将文件推到远端。回到仓库刷新后，便可看到提交的文件 第五步（2） （将代码推到github）（若读者是已经进行了第四步与第五步（2）可以先不进行本步骤操作）上一步是在复制代码至本地的基础上进行的，若没进行第四步的操作，直接将代码推到github上则需 新建需推到远端的文件如1.txt. 在文件夹中打开git命令窗口，输入git init进行初始化，此时系统会自动创建.git隐藏文件。 回到github仓库，先复制https链接，接着在命令窗口输入git remote add origin 复制好的链接 git pull origin master ，进行刷新 接着我们就可以进行提交操作 git add . git commi -m &quot;dev&quot; 由于这是初始化后的第一次推到远端，所以我们指出推到的分支，即输入如下命令，将文件推到master分支上 git push origin master 删除提交的文件可以直接在github上进行可视化的编辑，点击要删除的文件名，进入该文件在github中的文件属性页，进行如下图操作。 分支开发 依旧在文件夹中打开git命令行窗口。由于我们在远端github上执行了删除命令的操作，导致远端的文件与本地文件不同，这时便需要在命令行窗口输入指令git pull 并回车，进行刷新操作。（有时在不确定远端是否更改时也可以通过git pull指令来进行刷新） 刷新之后，通过指令git branch dev并回车，创建分支（dev是创建的分支名，在这里也可以随意命名分支）。 git checkout dev并回车,便切换到了dev分支。 在文件夹中创建文件dev.txt 提交分支文件，git add . git commi -m &quot;dev&quot;git push 此时由于是第一次在该分支提交文件，git push指令并没有是文件提交到远端，此时根据提示输入git push --set-upstream origin dev回车后，待push完毕后便可看到仓库中多了一个分支，分支中的文件便是刚提交的文件。（只有dev分支有dev.txt文件） 后续提交 返回文件夹新建dev2.txt文件提交分支文件，git add . git commi -m &quot;dev&quot;git push 此时发现不需输入指令git push --set-upstream origin dev便可提交到github中，其实，只有在切换分支后以及git的初始化后的第一次提交会提示需要在添加此指令，在以后的push过程中并不需要添加此指令。在github中查看，dev2.txt已上传完毕 合并dev分支至master git checkout master切换到主分支git pull刷新git merge dev合并请求git push推到github上回到仓库，切换到master分支，这时发现master分支多出了dev.txt和dev2.txt两个原本在dev分支上的文件。此时便说明分支合并成功了。值得注意的是，我们如今已切换到了master分支。若想将文件提交到刚刚的dev分支上则需先通过指令git checkout dev切换会dev分支，再进行陆续操作。 参考文章https://www.runoob.com/git/git-workspace-index-repo.html]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化_更改选中字符及超链接颜色]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8D%9A%E5%AE%A2%E9%80%89%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E8%B6%85%E9%93%BE%E6%8E%A5%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[前言NesT主题默认的选中字符颜色以及超链接颜色和周围网页、文字颜色相近不易区分。因此，选择手动更改二者颜色。 修改步骤第一步打开主题配置文件_config.yml查看自己选择的主题方案。在这里我选择的是scheme: Gemini，因此，接下来我也将以该方案为例。 第二步打开\themes\next\source\css\_schemes\Gemini\index.styl若已选择其他主题，则只需按路径打开_schemes文件夹下对应的方案，在选择打开对应的inde.styl文件即可。 第三步修改选中字符的颜色在上一步打开的文件末尾添加如下代码 12345// 修改选中字符的颜色::selection &#123; background: #3366ff; color: #FFFFFF; &#125; 选中字符后字符的颜色变为白色，选中的背景为蓝色。当然，也可以根据RGB颜色对照表在这里随意改成自己喜欢颜色。 第四步修改代码块选中的颜色打开，如下路径\themes\next\source\css\_common\components\highlight\highlight.style找到 123*::selection &#123; background: $highlight-selection; &#125; 修改为 1234//修改代码块颜色*::selection &#123; background: #3366ff; &#125; 这里更改代码块选中背景色为蓝色。 第五步修改超链接颜色打开\themes\next\source\css\_schemes\Gemini\index.styl在文件末尾添加如下代码 1234567891011// 文章内链接文本样式 .post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125; 参考文章https://www.jianshu.com/p/2a8d399f1266]]></content>
      <categories>
        <category>博客美化</category>
      </categories>
      <tags>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化_点击特效的实现]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%8D%9A%E5%AE%A2%E7%82%B9%E5%87%BB%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[简介本博客基于Hexo博客框架，主题选择的是NexT( NexT使用文档)。通过使用jQuery，为博客添加点击特效。 思路 通过jQuery click()函数，获取html标签中点击的事件，并调用相应方法 12$("html").click(function(e) &#123;&#125; 内置一个数组用来存储点击时出现的内容，通过jQuery设置返回的元素内容 123var a = new Array("奋斗!!!","努力!!!","Learning~","Coding~","Summarizing~","Advancing~","VENI","VIDI","VICI","٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ");var i = $("&lt;span&gt;&lt;/span&gt;").text(a[a_index]);a_index = (a_index + 1) % a.length; 在这里jQuery返回的数组内容顺序是按照数组a[0]有序读到最后的。若将 1a_index = (a_index + 1) % a.length; 替换为 1a_index = Math.round(Math.random()*a.length); 则将随机返回数组内的内容。 获取点击时鼠标的位置，将横纵坐标分别存储在变量x、y中。并在css中添加字体特效颜色，以及出现字体的位置。 123456789var x = e.pageX,y = e.pageY;i.css(&#123; "z-index": 66666666666666666666666666666666666666666666666666666666666, "top": y -10, "left": x, "position": "absolute", "font-weight": "bold", "color": "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" &#125;); 这里为保证特效不被遮挡一次设置一个较大的z-index。字体出现的初始位置为鼠标点击位置正上方10单位的位置上. 将字体添加到html中 1$("html").append(i); 通过jQuery animate()方法制作点击特效 12345678i.animate(&#123; "top": y-180 , "opacity": 0 &#125;, 1500, function() &#123; i.remove(); &#125;); 在这里设置动画的效果为特效字体从鼠标点击位置开始逐渐向上180个单位，上升的过程中逐渐淡化，在1.5秒后消失。 完整代码12345678910111213141516171819202122232425262728var a_index = 0;jQuery(document).ready(function($) &#123; $("html").click(function(e) &#123; var a = new Array("奋斗!!!","努力!!!","Learning~","Coding~","Summarizing~","Advancing~","VENI","VIDI","VICI","٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ"); var i = $("&lt;span&gt;&lt;/span&gt;").text(a[a_index]); a_index = (a_index + 1) % a.length; // a_index = Math.round(Math.random()*a.length);//随机出现点击内容 var x = e.pageX, y = e.pageY; i.css(&#123; "z-index": 66666666666666666666666666666666666666666666666666666666666, "top": y -10, "left": x, "position": "absolute", "font-weight": "bold", "color": "rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")" &#125;); $("html").append(i); i.animate(&#123; "top": y - 180 , "opacity": 0 &#125;, 1500, function() &#123; i.remove(); &#125;); &#125;);&#125;); 相关配置由于此博客选择的主题是NexT，因此有关的配置我也以NexT为例。 将上述js代码命名为special-effect.js，并移动到如下目录：\themes\next\source\js 在如下路径：\themes\next\layout\layout.swig找到倒数第二行的标签的前面添加如下代码 123&#123;% if theme.special-effect %&#125;&lt;script type="text/javascript" src="/js/special-effect.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在主题配置文件（\themes\next_congig.yml）末尾加入： 12#special-effectspecial-effect: true]]></content>
      <categories>
        <category>博客美化</category>
      </categories>
      <tags>
        <tag>点击特效</tag>
        <tag>JS</tag>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初心]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%88%9D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[初心 搭建此博客是为了总结学习过程中遇到的一些问题及其解决方法。 博客内容可能过于浅显，但是我将通过不断地学习来增加自身的知识储备，希望有朝一日此博客可以称谓“硬核”技术博客，并能实实在在的帮助自己及所需之人解决生活中一些细微的问题。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
</search>
