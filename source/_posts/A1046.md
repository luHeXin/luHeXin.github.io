---
title: PAT A1046 Shortest Distance (20 point(s))
date: 2019-08-11 14:38:51
tags:
- PAT
categories: PAT 甲级
---
# Problem Description
The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.
## Input Specification:
Each input file contains one test case. For each case, the first line contains an integer N (in [3,10<sup>6</sup>]), followed by N integer distances D<sub>1</sub>D<sub>2</sub>...D<sub>n</sub>
​​ , where D<sub>i</sub>
​​ is the distance between the i-th and the (i+1)-st exits, and D<sub>N</sub>
​​  is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10<sup>4</sup>), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10<sup>7</sup>
​.
## Output Specification:
For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.

## Sample Input:
5 1 2 4 14 9

3

1 3

2 5

4 1
## Sample Output:
3

10

7
<hr/>

# 题目大意：
N个节点围成一个圈，给定相邻节点的距离，求两节点之间的最小距离
# 样例分析：
在输入样例中，<br/>
第一行第一个数字，代表着有几个节点围成的一个圈，第一行的其他数字，表示1~2,2~3，...n-1~n节点之间的距离。

第二行中的数字N，表示接下来会给N对节点。

剩余的N行表示，具体需求出距离的的节点对。

在输出样例中，

输出N行节点之间的最短距离。
# 思路：
- 在一个圈中，两节点的距离无非是顺时针，逆时针两种情况，这两者中较小的距离，便是所需求的最短距离
- 定义一个变量sum来存放一周总距离，在定义一个数组dis[i]存放第一点到第i点的距离。
- 假设给定的两点分别为i<sub>1</sub>与i<sub>2</sub>,且保证若前者大于后者则交换，则两点之间顺时针的距离为dis[i<sub>2</sub>-1]-dis[i<sub>1</sub>-1]。
- 比较顺时针距离(dis[i<sub>2</sub>-1]-dis[i<sub>1</sub>-1])与逆时针距离(sum-dis[i<sub>2</sub>-1]-dis[i<sub>1</sub>-1])取较小的一个即可。
# 参考代码：
```c++
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN=100010;
int dis[MAXN],A[MAXN];//dis[]数组存放1到i顺时针距离

int main(){
    int sum=0,n,left,right;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&A[i]);
        sum+=A[i];
        dis[i]=sum;
    }
    int query;
    scanf("%d",&query);
    for(int i=0;i<query;i++){
        scanf("%d %d",&left,&right);
        if(left>right)swap(left,right);
        int temp=dis[right-1]-dis[left-1];
        printf("%d\n",min(temp,sum-temp));
    }
    return 0;

}
```

