---
title: PAT B1035 插入与归并 (25分)
date: 2021-01-04 22:41:47
tags:
- PAT
categories: PAT 乙级
---
# 题目描述
根据维基百科的定义：

插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。

归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。

现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？

# 输入格式
输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。
# 输出格式
首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。
# 输入样例 1
10

3 1 2 8 7 5 9 4 6 0

1 2 3 7 8 5 9 4 6 0
# 输出样例 1
Insertion Sort

1 2 3 5 7 8 9 4 6 0
# 输入样例 2
10

3 1 2 8 7 5 9 4 0 6

1 3 2 8 5 7 4 9 0 6
# 输出样例 2
Merge Sort

1 2 3 8 4 5 7 9 0 6
<hr/>

# 思路
模拟插入和归并排序过程，每进行一次迭代，与输入样例的第三行数据相比较，查看数据是否相同，若判断结果为相同，则还需进行一次迭代。

但注意的一点便是初始数据不参与比较。
## 数列比较
```c++
bool isSame(int a1[],int b1[]){
	for(int i=0;i<n;i++){
		if(a1[i]!=b1[i]) return false;
	}
	return true;
}
```
## 插入排序
```c++
int n;
void InsertSort(int a[]){
	for(int i=1 ; i<n ; i++){
		int temp=a[i];
		int j=i;
		while(j>0 && a[j-1]>temp){
			//向前挪,前面的值赋给后面 
			a[j]=a[j-1]; 
			j--; 
		}
		a[j]=temp;
	}
}
```
## 归并排序
```c++
int n;
void mergeSort(int a[]){
	for(int i=2 ; i/2<=n ; i*=2){
		for(int j=0 ; j<n ; j+=i){
			sort(a + j , a + min(i + j , n));
		}
	}
}
```

# 参考代码
``` c++
#include<cstdio> 
#include<algorithm>
#include<cmath>

using namespace std;

int n,a[101],b[101],ori[101];
bool isSame(int a1[],int b1[]){
	for(int i=0;i<n;i++){
		if(a1[i]!=b1[i]) return false;
	}
	return true;
}
void show(int a1[]){
	for(int i=0;i<n;i++){
		printf("%d",a1[i]);
		if(i!=n-1) printf(" ");
	}
}
bool InsertSort(){
	bool flag=false;
	for(int i=1;i<n;i++){
		if(i!=1&&isSame(ori,b)){
			flag=true;
		}
		int temp=ori[i];
		int j=i;
		while(j>0&&ori[j-1]>temp){
			//向前挪,前面的值赋给后面 
			ori[j]=ori[j-1]; 
			j--; 
		}
		ori[j]=temp;
		if(flag==true) return true; 
	}
	return false;
}

void mergeSort(){
	bool flag=false;
	for(int i=2;i/2<=n;i*=2){
		if(i!=2&&isSame(a,b)){
			flag=true;
		}
		for(int j=0;j<n;j+=i){
			sort(a+j,a+min(i+j,n));
		}
		if(flag==true) return; 
	}
}
int main(){
	scanf("%d",&n);

	for(int i=0;i<n;i++){
		scanf("%d",&a[i]);
		ori[i]=a[i];
	}
	for(int i=0;i<n;i++){
		scanf("%d",&b[i]);
	}
	if(InsertSort()){
		printf("Insertion Sort\n");
		show(ori);
	}else{
		printf("Merge Sort\n");
		mergeSort();
		show(a);
	}
	
	return 0; 
}
```