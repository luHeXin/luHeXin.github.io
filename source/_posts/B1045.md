---
title: PAT B1045 快速排序 (25分)
date: 2021-01-08 10:01:14
tags: PAT
categories: PAT 乙级
---
# 题目描述
著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

例如给定 $N = 5$, 排列是1、3、2、4、5。则：

* 1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
* 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
* 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
* 类似原因，4 和 5 都可能是主元。
因此，有 3 个元素可能是主元。
# 输入格式
输入在第 1 行中给出一个正整数 N(≤10<sup>5</sup>)； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10<sup>9</sup>。
# 输出格式
在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。
# 输入样例
5<br>
1 3 2 4 5
# 输出样例
3<br>
1 4 5
<hr>

# 思路
开辟两个数组left[i]、right[i],前者记录第i个元素(不包括第i个元素)左面最大的，由于样例元素为正整数，所以设置left[0]=0;后者记录第i个元素(不包括第i个元素)右边最小的，设置最后一个元素right[n-1]为一个极大的数。

* 若a[i]>left[i]说明第i个元素左面都比他小；

* 若a[i]<right[i]说明第i个元素右面都比他大。

所以a[i]便是一个主元。
# 参考代码
```c++
#include<cstdio>
#include<cstring>
#include<algorithm> 

using namespace std;

const int maxn=100010;
//left[i],为第i个元素左边最大的元素
//right[i]，为第i个元素右边最小的元素 
int a[maxn],left[maxn],right[maxn];
int max1=0x3fffffff;
int ans[maxn],num=0;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&a[i]);
	}
	
	left[0]=0;//第0个元素左边没有元素，由于测试样例为正整数，因此0最小
	for(int i=1;i<n;i++){
		left[i]=max(left[i-1],a[i-1]);
	} 
	
	right[n-1]=max1;//第n-1个元素右面没有元素，设置其为最大
	for(int i=n-2;i>=0;i--){
		right[i]=min(right[i+1],a[i+1]);
	} 
	
	for(int i=0;i<n;i++){
		if(left[i]<a[i]&&right[i]>a[i]){
			ans[num++]=a[i];
		}
	}
	printf("%d\n",num);
	sort(ans,ans+num);
	for(int i=0;i<num;i++){
		printf("%d",ans[i]);
		if(i<num-1) printf(" ");
	}
	printf("\n");
	return 0;
} 
```