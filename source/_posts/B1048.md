---
title: PAT B1048 数字加密 (20 point(s))
date: 2019-08-06 23:51:57
tags:
---
# 题目描述：
本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。
# 输入格式：
输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。
# 输出格式：
在一行中输出加密后的结果。
# 输入案例：
1234567 368782971
# 输出案例：
3695Q8118
# 题目分析：
简单的字符串处理问题。<br/>
对于输入案例，字符串读入的时候是a[0]='1',a[1]='2'....,但是，1234567的个位数字是7，题目要求`令个位为第一位`。因此，需要反转两次字符串，第一次是在，进行奇偶位数操作时；第二次，是在输出的时，转化字符串，使`个位`在字符串最右侧。
# 思路：
- 比较两字符串长度，选择较长的长度，作为循环上限。
- 分情况处理，奇偶位不同操作（这里的奇偶位与数组脚标的奇偶是相反的）。
- 注意两次字符串的反转。

# 参考代码：
``` c
#include<cstdio>
#include<cstring>

const int maxn = 110;
char a[maxn], b[maxn], ans[maxn];

void reverse(char s[]) {//反转字符
	int len = strlen(s);
	char temp;
	for (int i = 0; i < len / 2; i++) {
		temp = s[i];
		s[i] = s[len - i - 1];
		s[len - i - 1] = temp;
	}

}

int main() {
	scanf("%s %s", a, b);
	reverse(a);
	reverse(b);
	int lenA = strlen(a);
	int lenB = strlen(b);
	int len = lenA > lenB ? lenA : lenB;
	for (int i = 0; i < len; i++) {
		int numA = i < lenA ? a[i] - '0' : 0;//字符转化为整数，超过长度，零来补位
		int numB = i < lenB ? b[i] - '0' : 0;
		if (i % 2 == 0) {//i为偶数，奇数位
			int temp = (numA + numB) % 13;
			if (temp == 10)ans[i] = 'J';
			else if (temp == 11)ans[i] = 'Q';
			else if (temp == 12)ans[i] = 'K';
			else ans[i] = temp + '0';//转换为字符
		}
		else {
			int temp = numB - numA;
			if (temp < 0) temp += 10;
			ans[i] = temp + '0';//转换为字符
		}		
	}
	reverse(ans);//反转字符串
	puts(ans);
	return 0;

}
```