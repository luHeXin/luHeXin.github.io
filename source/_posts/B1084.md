---
title: PAT B1084外观数列 (20分)
date: 2021-01-10 21:29:13
tags: PAT
categories: PAT 乙级
---
# 题目描述
外观数列是指具有以下特点的整数序列：

d, d1, d111, d113, d11231, d112213111, ...

它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。
# 输入格式
输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。
# 输出格式
在一行中给出数字 d 的外观数列的第 N 项。
# 输入样例
1 8
# 输出样例
1123123111
<hr>

# 注意点
题目描述给的样例中第六轮的内容为d112213111，其含义为第四轮有`d` 1 个, `d` 后连续 2 个 `1` , 连续两个 `1` 后 1 个 `2` , `2` 后 1 个 `3` , `3` 后 1 个 `1` 。

以此种方法定义的数列不仅描述了元素的个数还描述了数列的先后顺序。

最初，我以为，该数列只描述元素的个数，例如第五轮是`d11231`，共有 `d` 1 个 ，`1` 3 个 ，`2` 1 个  , `3` 1个 。所以误认为第六轮应该是`d1132131`。在参考过https://www.liuchuo.net/archives/4646之后，我也将在参考代码2中给出这种理解的代码。

# 思路
* 由于每一轮结束后数组的长度不确定，因此，用`string`类型保存数组；
* 设置`int i,j;`将i,j看成是两个指针，同时指向上一轮的字符串,以
`d, d1, d111, d113, d11231, d112213111, ...`
为例, 假设当前是第4轮循环(循环轮次从1开始)，则i和j指向第3轮的结果即d111；
* `i`从字符串起始位置开始，直至指向字符串末尾为止；`j`从`i`指向的位置开始，直至指向的内容和i指向的内容不同或指向字符串末尾为止，即`s[i]!=s[j]`为止；
* 因此，`(int)j-i`便是字符s[i]的个数,设置`string t`,拼接字符`s[i]`的个数，即`t += s[i] + to_string(j - i)`;
* 字符串循环结束将`t`赋给`s`，完成本轮循环。

# 参考代码1
```c++
#include <iostream>

using namespace std;

int main() {
    string s;
    int n, j;
    cin >> s >> n;
    for (int cnt = 1; cnt < n; cnt++) {
        string t;
        //将i,j看成是两个指针，同时指向上一轮的字符串
		//i从字符串起始位置开始，直至指向字符串末尾为止
		//j从i指向的位置开始，直至指向的内容和i指向的内容不同或指向字符串末尾为止，即s[i]!=s[j]为止
		//因此，(int)j-i便是字符s[i]的个数 
        for (int i = 0; i < s.length(); i = j) {
            for (j = i; j < s.length() && s[j] == s[i]; j++);
            t += s[i] + to_string(j - i);
        }
        s = t;
    }
    cout << s;
    return 0;
}
```
# 参考代码2
并不是这道题的正解，是注意点中，误解题目含义的代码，本题的代码参见`参考代码1`。
```c++
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

int main() {
	string s;
	//flag[s[i]-0]记录字符 s[i]是否记录 
	int flag[500];
	int n, j,tempC;
	cin >> s >> n;
	for (int cnt = 1; cnt < n; cnt++) {
		string t;
		memset(flag,0,sizeof(flag));
		//遍历本轮次的字符串 
		for(int i=0; i<s.length(); i++) {
			//s[i]没有记录
			if(flag[s[i]-0]==0) {
				//s[i]出现的次数
				tempC=0;
				//遇到不同的字符，从不同字符开始遍历 
				for(int j=i; j<s.length(); j++) {
					if(s[j]==s[i]) {
						tempC++;
					}
				}
				t+=s[i]+to_string(tempC);
				flag[s[i]-0]=1;
			}
		}
		s = t;
	}
	cout << s;

	return 0;
}
```
# 参考
https://www.liuchuo.net/archives/4646