---
title: PAT B1014 福尔摩斯的约会 (20 point(s))
date: 2019-08-02 00:32:40
tags:
- PAT
categories: PAT 乙级
---
# 题目描述
大侦探福尔摩斯接到一张奇怪的字条：`我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&hgsfdk d&Hyscvnm`。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间`星期四 14:04`，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 `D`，代表星期四；第 2 对相同的字符是 `E` ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 `A` 到 `N` 表示）；后面两字符串第 1 对相同的英文字母 `s` 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。

## 输入格式：
输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。

## 输出格式：
在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。

## 输入样例：

3485djDkxh4hhGE 
2984akDfkkkkggEdsb 
s&hgsfdk 
d&Hyscvnm


## 输出样例：
THU 14:04
<hr/>

# 题意：
给出四个字符串，<br/>
前两个字符串内含有约会的星期，与约会的钟头;<br/>
后两个字符串内含有约会的具体分钟。<br/>
要求通过如下规则处理四个字符串，得到约会的具体时间，<br/>

星期：比较前两个字符串，确定同一位置第一对相同的大写字母，A~G分别代表星期一至星期日；<br/>
钟头：比较前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），0到9分别代表0点到9点、大写字母 `A` 到 `N`分别代表10点到23点；<br/>
分钟：比较后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。
<br/>

最后按`DAY HH:MM`格式输出。
# 思路：
字符串处理问题，通过三次循环处理，分别得到星期，钟头，分钟。
- 第一步：扫描前两个字符串，确定同一位置第一对相同的大写字母（A~G），与字符A的距离是多少，便是星期几。
- 第二步：在第一步的基础上，继续扫描前两个字符串，确定同一位置第二对相同的字符（数字与大写字母），将其转换为0~23。
- 第三步：扫描后两对字符串，确定出现的第一对相同字母的位置，第几个位置表示第几分钟。

# 参考代码：
``` C++
#include<cstdio>
#include<cstring>
int main() {
	char  week[7][4] = {"MON","TUE","WED","THU","FRI","SAT","SUN"};

	//接收输入4条字符串
	char str1[65];
	char str2[65];
	char str3[65];
	char str4[65];
	fgets(str1, 65, stdin);
	fgets(str2, 65, stdin);
	fgets(str3, 65, stdin);
	fgets(str4, 65, stdin);
	//得到字符串长度，为通过循环比较相同字符，做准备
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int len3 = strlen(str3);
	int len4 = strlen(str4);
	
	int i = 0;
	//寻找前两字符串第一对相同的大写字母，确定星期
	for (i = 0; i < len1&&i < len2; i++) {
		if (str1[i] == str2[i] && str1[i] >= 'A'&&str1[i] <= 'G') {//保证同位置字符相同，且全为大写字母
			printf("%s ", week[str1[i] - 'A']);
			break;
		}
	}
	//在上次循环的基础上，继续循环查找相同的字符，确定小时
	for (i++; i < len1&&i < len2; i++) {
		if (str1[i] == str2[i]) {//分别讨论当字符为数字，和大写字母两种情况
			if (str1[i] >= '0'&&str1[i] <= '9') {
				printf("%02d:", str1[i] - '0');
				break;
			}
			else if (str1[i] >= 'A'&&str1[i] <= 'N') {
				printf("%02d:", str1[i] - 'A' + 10);
				break;
			}			
		}
	}
	//确定后两字符串，第一对相同字符出现的位置
	for (i = 0; i < len3&&i < len4; i++) {
		if (str3[i] == str4[i]) {
			if ((str3[i] >= 'A'&&str3[i] <= 'Z') || (str3[i] >= 'a'&&str3[i] <= 'z')) {
				printf("%02d", i);
				break;
			}
		}
	}
	return 0;
}
```