---
title: CCF201412-2
date: 2020-04-19 17:23:32
tags:
- CCF
- 模拟
categories: 
- CCF计算机软件能力认证
---
问题链接：[CCF201412-2](http://118.190.20.162/view.page?gpid=T20)

# 问题描述
给定一个n×n的矩阵，左上角到右下角Z字形扫描输出该矩阵的元素。先输入正整数n，再输入n×n个整数。

# 题目分析
模拟<br/>
关键在于找到下标的变化规律，可以发现扫描过程中共有四种方向，即右，下，右上，左下四个方向<br/>
每进行一次的右或下的扫描后,则会进行若干次的右上或左下的扫描。不难发现最后一次扫描必定是右或下,第一次扫描必定是右<br/>
若此次是右扫描,且扫描位置在矩形的上边界,则下次一定会进行若干次的左下扫描。直至到达矩形的左边界或下边界<br/>
若此次是右扫描,且扫描位置在矩形的上边界,则下次一定会进行若干次的右上扫描。直至到达矩形的右边界或上边界<br/>
同理，此次若为上扫描，亦然，不在此多加赘述。
# 参考代码
```c++
#include<iostream>

using namespace std;

int main() {
	int n;
	cin>>n;
	int a[n+1][n+1];
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			cin>>a[i][j];
		}
	}
	
	if(n==1) {
		cout<<a[1][1];
		return 0;
	}
	
	cout<<a[1][1]<<" ";
	
	int ii=1,jj=1;
	//flag1=1表示可以右走，-1为向下走，为0是代表斜着走 
	//flag2=1代表斜向上走 ,-1表示斜向下走
	int flag1=1,flag2=1;
	while(1) {
		
		if(flag1==1){//右走 
			jj++;
			cout<<a[ii][jj]; 
			flag1=0;
			if(ii==1) flag2=-1;
			if(ii==n) flag2=1;
		} 
		else if(flag1==-1){//下走 
			ii++;
			cout<<a[ii][jj];
			flag1=0;
			if(jj==1) flag2=1;
			if(jj==n) flag2=-1;
		}
		if(ii>=n&&jj>=n) break;
		else cout<<" "; 
		
		while(flag2==-1&&flag1==0) { //斜向下走
			ii++;
			jj--;
			cout<<a[ii][jj]<<" ";
			
			if(jj==1&&ii!=n){
				flag1=-1;//向下走
				break; 
			}
			if(ii==n){
				flag1=1;//向右走
				break; 
			}
		}
		
		while(flag2==1&&flag1==0) { //斜向上走
			ii--;
			jj++;
			cout<<a[ii][jj]<<" ";
			if(ii==1&&jj!=n){
				flag1=1;//向右走
				break; 
			}
			if(jj==n){
				flag1=-1;//向下走
				break; 
			}
		}
	}
	
	return 0;
}
```
# 小结
- 当n=1时，需特殊讨论
- 因为赋值时，数组脚标从1至n的，因此开辟的数组大小为n+1