---
title: 二叉搜索树先序遍历与后序遍历之间的转换
date: 2020-03-11 23:00:10
tags: 二叉搜索树
categories: 数据结构
---
# 思路
在二叉搜索树中，左子树的所有结点的权值小于根结点的权值，右子树的所有结点的权值大于等于根结点的权值<br/>
根据二叉搜索树的这条特性便可以找到，先序(或后序)遍历数组中对应的左右子树的子序列，在多次递归即可。

# 已知二叉搜索树的先序遍历求其后序遍历
```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> pre,post;
void postOrder(int root,int end) {//root与end对应先序遍历数组的第一个元素下标，及最后一个元素下标 
	if(root>end) return;//递归边界
	int i=root+1;
	int j=end;
	//根据二叉搜索树right<root<left的特点，进行遍历,找到先序数组中左右子树的范围 
	//左子树序列是[root+1,j];
	//右子树序列是[i,end] 
	while(i<=end&&pre[root]>pre[i]) i++; //i从左子树序列第一个开始，搜索到右子树序列第一个结束 
	while(j>=root+1&&pre[root]<=pre[j]) j--; //j从右子树最后一个开始，搜索到左子树最后一个结束
	if(j+1!=i) return; 
	postOrder(root+1,j);//左子树 
	postOrder(i,end);//右子树 
	post.push_back(pre[root]);
}
int main() {
	int n;
	cin>>n;
	pre.resize(n);
	for(int i=0;i<n;i++){
		cin>>pre[i];
	}
	postOrder(0,n-1);
	for(auto it=post.begin();it!=post.end();it++){
		cout<<*it<<" ";
	} 
	return 0;
}
```
# 已知二叉搜索树的先序遍历求其后序遍历
```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> pre,post;
void preOrder(int root,int start){
	if(root<start) return;
	int i=root-1;
	int j=start;
	while(i>=start&&post[root]<=post[i]) i--;
	while(j<=root-1&&post[root]>post[j]) j++;
	if(i+1!=j) return;
	pre.push_back(post[root]);
	preOrder(i,start); //这里注意，左子树数组为[start,i],但由于数组是后序遍历数组，所以左子树的根是i 
	preOrder(root-1,j); 
}
int main() {
	int n;
	cin>>n;
	post.resize(100);
	for(int i=0;i<n;i++){
		cin>>post[i];
	}
	preOrder(n-1,0);
	for(auto it=pre.begin();it!=pre.end();it++){
		cout<<*it<<" ";
	} 
	return 0;
}
```