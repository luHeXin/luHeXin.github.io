---
title: 二叉树几种遍历方法间的转换
date: 2020-01-06 18:39:34
tags: 二叉树树
---
# 前言
二叉树的遍历是指通过一定顺序访问二叉树的所有结点。遍历方法一般有四种：先序遍历、中序遍历、后序遍历及层序遍历。<br/>
其中已知先序(或后序)与中序可以求出后序(或先序)遍历。但是，若只知道先序与后序则就不出中序遍历。
# 案例
已知如下一棵二叉树：
![](https://luhexin.github.io/images/二叉树几种遍历方法间的转换/1.png)<br/>
先序遍历：4 1 3 2 6 5 7<br/>
中序遍历：1 2 3 4 5 6 7<br/>
后序遍历：2 3 1 5 7 6 4<br/>
层序遍历：4 1 6 3 5 7 2<br/>
# 思路
- 先序遍历数组中第一个元素为根结点。
- 后序遍历数组最后一个元素则为根结点。
- 中序遍历数组中，找到根结点，则根结点左侧为左子树，右侧为右子树。
- 对于求层序遍历的问题，只需在先序或者是后序遍历过程中，用一个变量来记录当前根结点在⼆叉树中所对应的下标，根据下标进行结构体的排序，按顺序输出即可。
# 已知先序与中序求后序
``` c++
#include<cstdio>

int pre[32],in[32];//pre[]是先序遍历数组，in[]是中序遍历数组 

void post(int root,int start,int end){//root是先序遍历数组中的根节点脚标
	if(start>end) return; 
	int i=start;
	while(i<end&&in[i]!=pre[root]) i++;//i是中序遍历数组中根节点脚标
	post(root+1,start,i-1);//左子树递归
	post(root+1-start+i,i+1,end);//右子树递归
	printf("%d ",pre[root]);
}

int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&pre[i]);
	}
	for(int i=0;i<n;i++){
		scanf("%d",&in[i]);
	}
	post(0,0,n-1);
	return 0;
}
```
# 已知先序与中序求层序
``` c++
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

struct node{
	int index,value;
}; 
bool cmp(node a,node b){
	return a.index<b.index;
}
vector<node> ans;
vector<int> pre,in;

void post(int root,int start,int end,int index){//root是现需遍历数组中的根节点位置 
	if(start>end) return; 
	int i=start;
	while(i<end&&in[i]!=pre[root]) i++;//i是中序遍历数组中根节点位置 
	
	post(root+1,start,i-1,index*2+1);
	post(root+1-start+i,i+1,end,index*2+2);
	ans.push_back({index,pre[root]});
}

int main(){
	int n;
	scanf("%d",&n);
	pre.resize(n);
	in.resize(n);
	for(int i=0;i<n;i++){
		scanf("%d",&pre[i]);
	}
	for(int i=0;i<n;i++){
		scanf("%d",&in[i]);
	}

	post(0,0,n-1,0);
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i<ans.size();i++){
		if(i!=0) printf(" ");
		printf("%d",ans[i].value);
	}
	return 0;
}
```
# 已知后序与中序求先序
``` c++
#include<cstdio>

int post[32],in[32];//pre[]是先序遍历数组，in[]是中序遍历数组 

void pre(int root,int start,int end){//root是后序遍历数组中的根节点位置 
	if(start>end) return; 
	int i=start;
	while(i<end&&in[i]!=post[root]) i++;//i是中序遍历数组中根节点位置 
    printf("%d ",post[root]);
	pre(root-1-end+i,start,i-1);
	pre(root-1,i+1,end);

}

int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&post[i]);
	}
	for(int i=0;i<n;i++){
		scanf("%d",&in[i]);
	}
	pre(n-1,0,n-1);
	return 0;
}
```
# 已知后序与中序求层序
``` c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

struct node{
	int index,value;
}; 
bool cmp(node a,node b){
	return a.index<b.index;
}
vector<node> ans;
vector<int> post,in;
void pre(int root,int start,int end,int index){
	if(start>end){
		return;
	}
	int i=start;
	while(i<end&&post[root]!=in[i]) i++;
	ans.push_back({index,post[root]});
	pre(root-1-end+i,start,i-1,2*index+1);
	pre(root-1,i+1,end,2*index+2);
}
int main(){
	int n;
	scanf("%d",&n);
	post.resize(n);
	in.resize(n);
	for(int i=0;i<n;i++) scanf("%d",&post[i]);
	for(int i=0;i<n;i++) scanf("%d",&in[i]);
	pre(n-1,0,n-1,0);
	sort(ans.begin(),ans.end(),cmp);
	for(int i=0;i<ans.size();i++){
		if(i!=0) cout<<" ";
		cout<<ans[i].value;
	}
	return 0;
}
```
# 参考文章
[已知后序与中序输出前序（先序）](https://www.liuchuo.net/archives/2090)
