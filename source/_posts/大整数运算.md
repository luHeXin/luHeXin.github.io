---
title: 大整数运算
date: 2020-02-25 11:19:10
tags:
---
大整数又称为高精度整数，其含义就是用基本数据类型无法存储其精度的整数。

# 大整数的存储
``` c++
struct bign{
    int d[1000];    //存储大整数数据
    int len;    //存储大整数长度
    bign(){
        memset(d,0,sizeof(d));
        int len=0;
    }
}
```

为了方便后续的运算，整数的高位最好对应大整数数组的高位。
```c++
bign change(char s[]){
	bign ans;
	ans.len=strlen(s);
	for(int i=0;i<ans.len;i++){//整数的高位对应大整数数组的高位
		ans.d[i]=s[ans.len-1-i]-'0';
	}
	return ans;
} 
```

比较大整数大小:<br/>
1. 比较大整数长度
2. 按高位向低位依次比较
```c++
int compare(bign a,bign b) {
	if(a.len>b.len) return 1;
	else if(a.len<b.len) return -1;
	else {
		for(int i=a.len-1; i>=0; i--) {
			if(a.d[i]>b.d[i]) return 1;
			else if(a.d[i]<b.d[i]) return -1;
		}
		return 0;//二者相等
	}
}
```
# 大整数四则运算
## 加法
```c++
bign add(bign a,bign b){//加法 
	bign ans;
	int carry=0;	//carry保留进位
	for(int i=0;i<a.len||i<b.len;i++){
		int temp=a.d[i]+b.d[i]+carry;
		carry=temp/10;
		ans.d[ans.len++]=temp%10;
	} 
	if(carry!=0){//还得继续进一位 
		ans.d[ans.len++]=carry; 
	}
	return ans;
}
```

## 减法
```c++
bign sub(bign a,bign b){//减法 
	if(compare(a,b)==-1){//交换被减数与减数，保证被减数大 
		bign temp=a;
		a=b;
		b=temp; 
		printf("-");//输出负号 
	}
	bign ans;
	for(int i=0;i<a.len||i<b.len;i++){
		if(a.d[i]<b.d[i]){//不够减 
			a.d[i+1]--;//借位
			a.d[i]+=10; 
		}
		ans.d[ans.len++]=a.d[i]-b.d[i];
	}
	while(ans.len-1>=1&&ans.d[ans.len-1]==0){
		ans.len--;
	}
	return ans;
}
```

## 乘法
```c++
bign multi(bign a,int b){//乘法 
	bign ans;
	int carry=0;
	for(int i=0;i<a.len;i++){
		int temp=a.d[i]*b+carry;
		ans.d[ans.len++]=temp%10;
		carry=temp/10;
	}
	while(carry!=0){//最后还有进位 
		ans.d[ans.len++]=carry%10;
		carry/=10; 
	}
	return ans;
}
```

## 除法
```c++
bign div(bign a,int b,int &r){//r保存余数,初值应为零
	bign ans;
	ans.len=a.len;
	for(int i=a.len-1;i>=0;i--){//除法从高位开始
		r=r*10+a.d[i];
		if(r<b) ans.d[i]=0;//不够除,0补位,继续下一位的计算 
		else{//够除 
			ans.d[i]=r/b;
			r=r%b;//更新余数 
		} 
	}
	while(ans.len-1>=1&&ans.d[ans.len-1]==0) {
		ans.len--;//高位为零，舍去。but，各位都是零，个位不舍 
	}
	return ans;
} 
```
## Demo
``` c++
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;

struct bign {
	int len;
	int d[1000];
	bign() {
		memset(d,0,sizeof(d));
		len=0;
	}
};

bign change(char s[]) {//转化为大整数，大整数低位存储数据低位 
	bign ans;
	ans.len=strlen(s);
	for(int i=0; i<ans.len; i++) {
		ans.d[i]=s[ans.len-1-i]-'0';
	}
	return ans;
}
int compare(bign a,bign b) {//比较大小 
	if(a.len>b.len) return 1;
	else if(a.len<b.len) return -1;
	else {
		for(int i=a.len-1; i>=0; i--) {
			if(a.d[i]>b.d[i]) return 1;
			else if(a.d[i]<b.d[i]) return -1;
		}
		return 0;//二者相等
	}
}

bign add(bign a,bign b){//加法 
	bign ans;
	int carry=0;	//carry保留进位
	for(int i=0;i<a.len||i<b.len;i++){
		int temp=a.d[i]+b.d[i]+carry;
		carry=temp/10;
		ans.d[ans.len++]=temp%10;
	} 
	if(carry!=0){//还得继续进一位 
		ans.d[ans.len++]=carry; 
	}
	return ans;
}

bign sub(bign a,bign b){//减法 
	if(compare(a,b)==-1){//交换被减数与减数，保证被减数大 
		bign temp=a;
		a=b;
		b=temp; 
		printf("-");//输出负号 
	}
	bign ans;
	for(int i=0;i<a.len||i<b.len;i++){
		if(a.d[i]<b.d[i]){//不够减 
			a.d[i+1]--;//借位
			a.d[i]+=10; 
		}
		ans.d[ans.len++]=a.d[i]-b.d[i];
	}
	while(ans.len-1>=1&&ans.d[ans.len-1]==0){
		ans.len--;
	}
	return ans;
}

bign multi(bign a,int b){//乘法 
	bign ans;
	int carry=0;
	for(int i=0;i<a.len;i++){
		int temp=a.d[i]*b+carry;
		ans.d[ans.len++]=temp%10;
		carry=temp/10;
	}
	while(carry!=0){//最后还有进位 
		ans.d[ans.len++]=carry%10;
		carry/=10; 
	}
	return ans;
}
bign div(bign a,int b,int &r){//r保存余数,初值应为零
	bign ans;
	ans.len=a.len;
	for(int i=a.len-1;i>=0;i--){//除法从高位开始
		r=r*10+a.d[i];
		if(r<b) ans.d[i]=0;//不够除,0补位,继续下一位的计算 
		else{//够除 
			ans.d[i]=r/b;
			r=r%b;//更新余数 
		} 
	}
	while(ans.len-1>=1&&ans.d[ans.len-1]==0) {
		ans.len--;//高位为零，舍去。but，各位都是零，个位不舍 
	}
	return ans;
} 
void print(bign a){//输出 
	for(int i=a.len-1;i>=0;i--){
		printf("%d",a.d[i]);
	}
}
int main() {
	int q=9;//乘法乘数，除法除数 
	int r=0;//保留余数 
	char s1[1000],s2[1000];
	cin>>s1>>s2;
	//转换为大整数 
	bign a=change(s1);
	bign b=change(s2);
	
	bign add1=add(a,b);	//加 
	bign sub1=sub(a,b);	//减
	bign multi1=multi(a,q); //乘 
	bign div1=div(a,q,r); //除 
	print(add1); 
	return 0;
}
}
```

## Tips
* 加法与乘法要注意最后进位的处理，比如99+11，各位相加以后，还要最后进一位，进位到百位。
* 乘法的最后进位可能不止一位，所以最后要用while，如100*100=10000最后在百位的基础上又近了两位。
* 减法和除法要注意高位零的舍去，但是，假如全是零，例如0000000，则要保留个位的0