---
title: 并查集
date: 2020-01-31 17:10:10
tags: PAT模板
categories: PAT模板
---
# 简介
并查集是一种维护集合的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。<br/>
并查集中的查询指的是判断两个元素是否在一个集合。对同一个集合来说只存在一个根节点，且将其作为所属集合的标识。
# 并查集实现
并查集的实现就是一个数组<br/>
```c++
int father[N];
```
father[i]表示元素i的直属父节点，对于根节点而言，father[i]=i。

# 并查集的基本操作
##  初始化
``` c++
int father[N];
void init(int n){
    for(int i=;i<n;i++){
        father[i]=i;
    }
}

```
## 查找
由于并查集每个集合只有一个根节点，因此并查集的根节点可视为集合的标识，查找的结果便是返回该集合的根节点。
```c++
int findFather(int x){
    while(x!=father[x]){//根节点的father为自身
        x=father[x];//不断地更新x，直至到达根节点
    }
    return x;
}
```
## 合并
合并的基础是查询，先查找两个元素所在集合的根节点，若根节点不相同，则说明元素所在集合不相同，将其中一个集合的根节点的父亲指向另一个集合的根节点即可。
```c++
void Union(int A,int B){
    int faA=findFather(A);
    int faB=findFather(B);
    if(faA!=faB){
        father[faA]=faB;//进行合并
    }
}
``` 
## 计算集合个数
``` c++
int isRoot[N];//判断该节点是否为根结点，是为1，不是为0，但是注意要进行初始化附零处理，这里不加赘述
int calBlock(int n){//n为总共元素数目，元素序号从1~n
	int block=0;
	for(int i=1;i<=n;i++){
		isRoot[findFather(i)]=1;//将根节点赋值为1
	}
	for(int i=1;i<=n;i++){
		block+=isRoot[i];//计算根节点数目（由于一个集合只有一个根节点，因此几个根节点，便是几个集合）
	}
	return block;
}
```