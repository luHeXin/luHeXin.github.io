---
title: 数学问题
date: 2021-01-22 10:17:06
tags: 数学问题
categories: 数学问题
---
# 最大公约数与最小公倍数
## 最大公因式
```c++
//最大公因式
int gcd(int a,int b){
    return !b ? a : gcd(b , a % b);
}
```
## 最小公倍数
```c++
//最小公倍数
int lcm(int a,int b){
    int d = gcd(a , b);//d保存a与b的最小公倍数
    return a / d * b;
}
```
<hr>

# 素数
## 素数判断
```c++
bool isPrime(int n){
    if(n<=1) return false;
    for(int i=2; i*i<=n; i++){
        if (n % i == 0) return false;
    }
    return true;
}
```
## 素数表获取
```c++
//求解100以内的所有素数
const int maxn = 101;//表长
int prime[maxn], pnum=0; //前者存放所有的素数，后者存放素数个数
void Find_Prime(){
    for(int i = 1; i < maxn; i++){
        //判断是否为素数
        if(isPrime(i) == true){
            prime[num++] = i;
        }
    }
}

```
<hr>

# 质因子分解
质因子分解：将一个正整数n写成一个或多个质数的乘积的形式。由于每个质因子出现不止一次，因此定义结构体factor，用来存放质因子及其个数。
```c++
struct factor{
    int x,cnt;
}fac[10];//对于int型，数组开到10即可
```
```c++
//质因子分解(分解 int n)

//1、枚举1~sqrt(1.0*n)内所有质数p，判断p是否是n的因子
int n, num=0;
for(int i = 0; prime[i] <= sqrt(1.0 * n) && i < pnum; i++){//prime[i]存放整数n所有的素数, pnum为整数n的质数个数
    if(n % prime[i] == 0){//记录该质因子
        fac[num].x = prime[i]；
        fac[num].cnt = 0;
        while(n % prime[i] == 0){
            fac[num].cnt++;
            n/=prime[i];
        }
        num++;
    }
    if(n == 1) break;
}
//2、如果上述结束后，n还是大于1，说明n有且只有一个大于sqrt(1.0*n)的质因子(可能是n本身)(如6=2 x 3, 3大于根号6)
if(n != 1){
    fac[num].x = n;
    fac[num++].cnt = 1;
}
```
<hr>

# 分数的四则运算
## 分数的表示
```c++
struct Fraction{
    int up,down;
};
```
## 分数的化简
```c++
Fraction reduction(Fraction result){
    if(result.down<0){//分母小于零
        result.up = -result.up;
        result.down = -result.down;
    }
    if(result.up == 0){
        result.dpwn = 1;
    }else{
        int d = gcd(abs(result.up), abs(result.down));//求分子分母的最大公因式
        result.up /= d;
        result.down /= d;
    }
    return result;
}
```

## 分数加法
```c++
Fraction add(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down + f1.down * f2.up;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

## 分数减法
```c++
Fraction minu(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down - f1.down * f2.up;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

## 分数乘法
```c++
Fraction multi(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.up;
    result.down = f1.down * f2.down;
    return reduction(result);
}
```

## 分数除法
```c++
Fraction divide(Fraction f1, Fraction f2){
    Fraction result;
    result.up = f1.up * f2.down;
    result.down = f1.down * f2.up;
    return reduction(result);
}
```

## 分数的输出
```c++
void showResult(Fraction f){
    r = reduction(r);
    if(r.down == 1) printf("%d", r.up); //整数
    else if(abs(r.up) > r.down){//假分数
        printf("%d %d/%d", r.up / r.down, abs(r.up) % r.down, r.down);
    }else{//真分数
        printf("%d/%d", r.up, r.down);
    }
}
```
<hr>