---
title: 最大子列
date: 2019-09-27 18:12:53
tags:
- 浙大数据结构编程练习
categories: 浙大数据结构编程练习
---
# 说明：
此题选自中国大学MOOC上浙大数据结构的编程练习题目，本文将提供针对此题的三种解法（C++）。
# 解法一：
## 思路：
- 确立数组中的两个脚标i,j；
- 确立一个变量temp，temp值在i与j之间；
- 求得脚标为i到temp的数组元素的和；
- 以上为一个过程，分别枚举i和j即为全过程。
## 时间复杂度：
O(n<sup>3</sup>)
## 参考代码：
``` c++
#include<cstdio>

const int maxn = 100010;
int main() {
	int k, a[maxn] = {0}, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);

	for (int k1 = 0; k1 < k; k1++) {//读入数组中的值
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {//枚举
		for (int j = i; j < k; j++) {//枚举a[i]之后的元素
			thisSum = 0;//记录a[i]~a[j]之间子列和
			for (temp = i; temp <= j; temp++) {//temp为a[i]~a[j]之间的值
				thisSum += a[temp];
			}
			if (thisSum > maxSum) {//交换
				maxSum = thisSum;
			}
		}
	}
	printf("%d", maxSum);
	return 0;
}
```
<hr/>

# 解法二：
## 思路：
- 确立一个脚标i，确立一个变量j；
- j的值从i一直到数组的长度对应的值（k）进行枚举；
- 每一次枚举求一次脚标i到脚标j的数组元素值的和；
- 最后枚举i。
## 时间复杂度：
O(n<sup>2</sup>)
## 参考代码：
```c++
#include<cstdio>

const int maxn = 100100;

int main() {
	int k, a[maxn] = { 0 }, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);
	for (int k1 = 0; k1 < k; k1++) {
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {
		thisSum = 0;
		for (int j = i; j < k; j++) {
			thisSum += a[j];
			if (maxSum < thisSum) {
				maxSum = thisSum;
			}
		}
	}

	printf("%d", maxSum);
	return 0;
}
```

# 解法三：在线处理
## 思路：
- 枚举变量i；
- 时刻判断当前子列和是否为负，若当前子列和为负数，不可能后面的部分增大，所以此时应另起锅灶，下一个元素定为新子列的第一个元素。
## 时间复杂度：
O(n<sup>2</sup>)
## 参考代码：
```c++
#include<cstdio>

#include<cstdio>

const int maxn = 100100;

int main() {
	int k, a[maxn] = { 0 }, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);
	for (int k1 = 0; k1 < k; k1++) {
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {
		thisSum += a[i];
		if (maxSum < thisSum) {
			maxSum = thisSum;
		}
		else if (thisSum < 0) {//当前子列和为负数
			thisSum = 0;//不可能后面的部分增大，因此抛弃，将子列和归零，接着计算
		}
	}

	printf("%d", maxSum);
	return 0;
}
```