---
title: 01-复杂度1 最大子列和问题 (20 分)
date: 2019-09-27 18:12:53
tags:
- 浙大数据结构编程练习
categories: 浙大数据结构编程练习
---
# 题目描述：
给定K个整数组成的序列{ N1, N2 , ..., N<sub>​k</sub> }，“连续子列”被定义为{ Ni
, N<sub>​i+1</sub>, ..., Nj}，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：与样例等价，测试基本正确性；
- 数据2：102个随机整数；
- 数据3：103个随机整数；
- 数据4：104个随机整数；
- 数据5：105个随机整数；

## 输入格式:
输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。
## 输出格式：
在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。
## 输入样例：
6

-2 11 -4 13 -5 -2
## 输出样例：
20
<br/>

# 说明：
此题选自中国大学MOOC上浙大数据结构的编程练习题目，本文将提供针对此题的三种解法（C++）。
# 解法一：
## 思路：
- 确立数组中的两个脚标i,j；
- 确立一个变量temp，temp值在i与j之间；
- 求得脚标为i到temp的数组元素的和；
- 以上为一个过程，分别枚举i和j即为全过程。
## 时间复杂度：
O(n<sup>3</sup>)
## 参考代码：
``` c++
#include<cstdio>

const int maxn = 100010;
int main() {
	int k, a[maxn] = {0}, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);

	for (int k1 = 0; k1 < k; k1++) {//读入数组中的值
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {//枚举
		for (int j = i; j < k; j++) {//枚举a[i]之后的元素
			thisSum = 0;//记录a[i]~a[j]之间子列和
			for (temp = i; temp <= j; temp++) {//temp为a[i]~a[j]之间的值
				thisSum += a[temp];
			}
			if (thisSum > maxSum) {//交换
				maxSum = thisSum;
			}
		}
	}
	printf("%d", maxSum);
	return 0;
}
```
<hr/>

# 解法二：
## 思路：
- 确立一个脚标i，确立一个变量j；
- j的值从i一直到数组的长度对应的值（k）进行枚举；
- 每一次枚举求一次脚标i到脚标j的数组元素值的和；
- 最后枚举i。
## 时间复杂度：
O(n<sup>2</sup>)
## 参考代码：
```c++
#include<cstdio>

const int maxn = 100100;

int main() {
	int k, a[maxn] = { 0 }, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);
	for (int k1 = 0; k1 < k; k1++) {
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {
		thisSum = 0;
		for (int j = i; j < k; j++) {
			thisSum += a[j];
			if (maxSum < thisSum) {
				maxSum = thisSum;
			}
		}
	}

	printf("%d", maxSum);
	return 0;
}
```

# 解法三：在线处理
## 思路：
- 枚举变量i；
- 时刻判断当前子列和是否为负，若当前子列和为负数，不可能后面的部分增大，所以此时应另起锅灶，下一个元素定为新子列的第一个元素。
## 时间复杂度：
O(n<sup>2</sup>)
## 参考代码：
```c++
#include<cstdio>

#include<cstdio>

const int maxn = 100100;

int main() {
	int k, a[maxn] = { 0 }, temp;
	int thisSum = 0, maxSum = 0;
	scanf("%d", &k);
	for (int k1 = 0; k1 < k; k1++) {
		scanf("%d", &a[k1]);
	}

	for (int i = 0; i < k; i++) {
		thisSum += a[i];
		if (maxSum < thisSum) {
			maxSum = thisSum;
		}
		else if (thisSum < 0) {//当前子列和为负数
			thisSum = 0;//不可能后面的部分增大，因此抛弃，将子列和归零，接着计算
		}
	}

	printf("%d", maxSum);
	return 0;
}
```